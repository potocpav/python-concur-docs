<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>concur.extra_widgets.pan_zoom API documentation</title>
<meta name="description" content="Zoomable, pannable widget with arbitrary content â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>concur.extra_widgets.pan_zoom</code></h1>
</header>
<section id="section-intro">
<p>Zoomable, pannable widget with arbitrary content.</p>
<p>This widget is rarely used directly by user code. Most of the time, it's more convenient to use
higher-level widgets <a title="concur.extra_widgets.image.image" href="image.html#concur.extra_widgets.image.image"><code>image()</code></a>, or <a title="concur.extra_widgets.frame.frame" href="frame.html#concur.extra_widgets.frame.frame"><code>frame()</code></a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; Zoomable, pannable widget with arbitrary content.

This widget is rarely used directly by user code. Most of the time, it&#39;s more convenient to use
higher-level widgets `concur.extra_widgets.image.image`, or `concur.extra_widgets.frame.frame`.
&#34;&#34;&#34;


import copy
import numpy as np

import imgui
from concur.widgets import child, invisible_button
from concur.core import orr, forever, optional, map as cmap
from concur.extra_widgets.draggable import draggable


def pan_zoom(name, state, width=None, height=None, content_gen=None, drag_tag=None, down_tag=None):
    &#34;&#34;&#34; Create the Pan &amp; Zoom widget, serving as a container for a thing given by `content_gen`.

    This widget is mostly not used directly. Instead, a special-purpose wrapper can be used,
    such as `concur.extra_widgets.image.image`, or `concur.extra_widgets.frame.frame`.

    Arguments:
        name: widget name. Also serves as an event identifier
        state: `PanZoom` object representing state.
        width: widget width in pixels. If `None`, it fills the available space.
        height: widget height in pixels. If `None`, it fills the available space.
        content_gen: Widget generator to display inside the pan-zoom widget. All events are passed
            through as a return tuple member. This is a function that takes the
            `concur.extra_widgets.pan_zoom.TF` object, and returns a Concur
            widget. It is up to the widget to do the necessary transformations
            using the `TF` object.
        drag_tag: The event tag for LMB drag events. If `None`, no drag events are fired.
        down_tag: The event tag for LMB down events. If `None`, no down events are fired.
            Useful in combination with `drag_tag` to indicate when the dragging started.

    Returns:
        To ease integration with other widgets, this widget returns events in a special format:
        `(name, state, event)`. `state` or `event` may be `None` in case `state` didn&#39;t change,
        or there is no `event`.

        If `drag_tag`, or `down_tag` arguments are used, these are fired in the `event` member of the return tuple.
    &#34;&#34;&#34;
    assert content_gen is not None
    tf, content = None, None
    while True:
        assert not state.keep_aspect or not state.fix_axis, \
            &#34;Can&#39;t fix axis and keep_aspect at the same time.&#34;
        # Dynamically rescale width and height if they weren&#39;t specified
        if width is None:
            w = imgui.get_content_region_available()[0]
        else:
            w = width
        if height is None:
            h = imgui.get_content_region_available()[1]
        else:
            h = height
        frame_w = max(1, w - state.margins[0] + state.margins[2])
        frame_h = max(1, h - state.margins[1] + state.margins[3])
        w = max(1, w)
        h = max(1, h)

        zoom_x = frame_w / (state.right  - state.left)
        zoom_y = frame_h / (state.bottom - state.top)

        left, right = state.left, state.right
        top, bottom = state.top, state.bottom
        if state.keep_aspect:
            aspect = float(state.keep_aspect)
            assert state.keep_aspect &gt; 0, &#34;Negative aspect ratio is not supported.&#34;
            if abs(zoom_x) &gt; abs(zoom_y) * aspect:
                zoom_x = np.sign(zoom_x) * abs(zoom_y) * aspect
                center_x = (left + right) / 2
                left  = center_x - frame_w / zoom_x / 2
                right = center_x + frame_w / zoom_x / 2
            if abs(zoom_y) &gt; abs(zoom_x) / aspect:
                zoom_y = np.sign(zoom_y) * abs(zoom_x) / aspect
                center_y = (top + bottom) / 2
                top    = center_y - frame_h / zoom_y / 2
                bottom = center_y + frame_h / zoom_y / 2

        origin = imgui.get_cursor_screen_pos()

        imgui.begin_child(&#34;Pan-zoom&#34;, w, h, False, flags=imgui.WINDOW_NO_SCROLLBAR | imgui.WINDOW_NO_SCROLL_WITH_MOUSE) # needs to be before is_window_hovered

        # Interaction
        st = copy.deepcopy(state)
        io = imgui.get_io()
        is_window_hovered = imgui.is_window_hovered()

        if (imgui.is_mouse_clicked(1) or imgui.is_mouse_clicked(2)) and is_window_hovered:
            st.is_rmb_dragged = True
        if not (io.mouse_down[1] or io.mouse_down[2]):
            st.is_rmb_dragged = False

        delta = io.mouse_delta

        # Pan
        if st.is_rmb_dragged and (delta[0] or delta[1]):
            if st.fix_axis != &#39;x&#39;:
                st.left -= delta[0] / zoom_x
                st.right -= delta[0] / zoom_x
            if st.fix_axis != &#39;y&#39;:
                st.top -= delta[1] / zoom_y
                st.bottom -= delta[1] / zoom_y

        # Zoom
        if (imgui.is_window_hovered() or st.is_rmb_dragged) and io.mouse_wheel:
            factor = 1.3 ** io.mouse_wheel

            if st.fix_axis != &#39;x&#39;:
                mx_rel = (io.mouse_pos[0] - origin[0] - state.margins[0]) / frame_w * 2 - 1
                mx = mx_rel * (right - left) / (st.right - st.left) / 2 + 0.5
                wi = st.right - st.left
                st.left  = st.left    + wi * mx     - wi / factor * mx
                st.right = st.right   - wi * (1-mx) + wi / factor * (1-mx)

            if st.fix_axis != &#39;y&#39;:
                my_rel = (io.mouse_pos[1] - origin[1] - state.margins[1]) / frame_h * 2 - 1
                my = my_rel * (bottom - top) / (st.bottom - st.top) / 2 + 0.5
                hi = st.bottom - st.top
                st.top    = st.top    + hi * my     - hi / factor * my
                st.bottom = st.bottom - hi * (1-my) + hi / factor * (1-my)

        # Get screen-space bounds disregarding the margins
        left_s = left - st.margins[0] / zoom_x
        top_s =   top - st.margins[1] / zoom_y
        right_s = right - st.margins[2] / zoom_x
        bottom_s = bottom - st.margins[3] / zoom_y


        s2c = np.array([ # Screen to Content
            [1 / zoom_x, 0, left_s - origin[0] / zoom_x],
            [0, 1 / zoom_y, top_s  - origin[1] / zoom_y]])

        c2s = np.array([ # Content to Screen
            [zoom_x, 0, origin[0] - left_s * zoom_x],
            [0, zoom_y, origin[1] - top_s  * zoom_y]])

        view_s = [origin[0], origin[1], origin[0] + w, origin[1] + h]
        view_c = [left_s, top_s, right_s, bottom_s]

        content_value = None
        # coord_to_content = lambda x:
        try:
            new_tf = TF(c2s, s2c, view_c, view_s)
            if tf is None or tf != new_tf:
                tf = new_tf
                w, h = tf.view_s[2] - tf.view_s[0], tf.view_s[3] - tf.view_s[1]
                content = orr([
                    content_gen(tf),
                    cmap(lambda k: (k[0], [tf.s2c[0,0] * k[1].x, tf.s2c[1,1] * k[1].y]),
                        optional(drag_tag is not None,
                            draggable, drag_tag, forever(invisible_button, &#34;&#34;, w, h)
                            )
                        ),
                    ])
            next(content)
        except StopIteration as e:
            content_value = e.value
        finally:
            imgui.end_child()
        changed = st != state

        if down_tag and not st.is_rmb_dragged and imgui.is_mouse_clicked() and is_window_hovered:
            return name, (None, (down_tag, tf.inv_transform(np.array([[*io.mouse_pos]]))[0]))

        if changed or content_value is not None:
            return name, (st if changed else None, content_value)
        yield


class PanZoom(object):
    &#34;&#34;&#34; Pan &amp; zoom state. &#34;&#34;&#34;
    def __init__(self, top_left, bottom_right, keep_aspect=True, fix_axis=None, margins=[0, 0, 0, 0]):
        &#34;&#34;&#34;
        Arguments:
            top_left:     Coordinates of the top left corner of the displayed content area.
            bottom_right: Coordinates of the bottom right corner of the displayed content area.
            keep_aspect:  Keep aspect ratio (x/y) equal to a given constant and zoom proportionally.
                          if keep_aspect==True, it is equivalent to keep_aspect==1.
            fix_axis:     Do not zoom in a given axis (`&#39;x&#39;`, `&#39;y&#39;`, or `None`).
            margins:      Margins (left, top, right, bottom) of the view area in pixels.
                          If the view area should be inset by 5 px on each side, then use
                          margins=[5,5,-5,-5].
        &#34;&#34;&#34;
        self.reset_view(top_left, bottom_right)
         # Include cases where cursor is outside the element, but was inside when the drag started.
         # Exclude cases where cursor is inside the element, but was outside when the drag started.
        self.is_rmb_dragged = False
        self.is_lmb_dragged = False
        self.margins = margins

        self.keep_aspect = keep_aspect
        self.fix_axis = fix_axis

    def reset_view(self, top_left=None, bottom_right=None):
        &#34;&#34;&#34; Reset view to default values. &#34;&#34;&#34;
        if top_left is not None:
            self.default_left = top_left[0]
            self.default_top = top_left[1]
        if bottom_right is not None:
            self.default_right = bottom_right[0]
            self.default_bottom = bottom_right[1]
        self.top = self.default_top
        self.bottom = self.default_bottom
        self.left = self.default_left
        self.right = self.default_right

    def __eq__(self, other):
        return self.__dict__ == other.__dict__


class TF(object):
    &#34;&#34;&#34; Transformation object containing information necessary for converting between screen-space and image-space.

    Screen-space coordinates are in pixels with top-left window corner equal to (0, 0). Image space is
    arbitrary, given by the respective PanZoom widget state. Transformations are expressed as NumPy
    matrices in homogenous coordinates with two rows and three columns (shape: `(2, 3)`).

    For example, a point `[px, py]` can be transformed to screen-space by left multiplication:

    ```python
    q = np.matmul(c2s, [px, py, 1])
    ```

    Mostly, the necessary conversions are performed by overlay widgets in `concur.draw`.
    It may be useful to transform stuff by hand in cases when default behavior is not sufficient,
    such as specifying the line width in image coordinates.

    Attributes:
        c2s:      Content-to-screen transformation matrix.
        s2c:      Screen-to-content transformation matrix.
        view_s:   Screen-space viewport coordinates as a list [left, top, right, bottom].
        view_c:   Image-space viewport coordinates as a list [left, top, right, bottom].
    &#34;&#34;&#34;
    def __init__(self, c2s, s2c, view_c, view_s):
        self.c2s = c2s
        self.s2c = s2c
        self.view_c = view_c
        self.view_s = view_s

    def __eq__(self, other):
        return \
            np.array_equal(self.c2s, other.c2s) and \
            np.array_equal(self.s2c, other.s2c) and \
            self.view_c == other.view_c and \
            self.view_s == other.view_s and \
            True

    def transform(self, points):
        &#34;&#34;&#34;Transform a given NumPy array of `n` points of shape `(n, 2)` from content-space to screen-space.&#34;&#34;&#34;
        return np.tensordot(np.hstack([points, np.ones((points.shape[0], 1))]), self.c2s, (1, 1))

    def inv_transform(self, points):
        &#34;&#34;&#34;Transform a given NumPy array of `n` points of shape `(n, 2)` from screen-space to content-space.&#34;&#34;&#34;
        return np.tensordot(np.hstack([points, np.ones((points.shape[0], 1))]), self.s2c, (1, 1))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="concur.extra_widgets.pan_zoom.pan_zoom"><code class="name flex">
<span>def <span class="ident">pan_zoom</span></span>(<span>name, state, width=None, height=None, content_gen=None, drag_tag=None, down_tag=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Create the Pan &amp; Zoom widget, serving as a container for a thing given by <code>content_gen</code>.</p>
<p>This widget is mostly not used directly. Instead, a special-purpose wrapper can be used,
such as <a title="concur.extra_widgets.image.image" href="image.html#concur.extra_widgets.image.image"><code>image()</code></a>, or <a title="concur.extra_widgets.frame.frame" href="frame.html#concur.extra_widgets.frame.frame"><code>frame()</code></a>.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>widget name. Also serves as an event identifier</dd>
<dt><strong><code>state</code></strong></dt>
<dd><a title="concur.extra_widgets.pan_zoom.PanZoom" href="#concur.extra_widgets.pan_zoom.PanZoom"><code>PanZoom</code></a> object representing state.</dd>
<dt><strong><code>width</code></strong></dt>
<dd>widget width in pixels. If <code>None</code>, it fills the available space.</dd>
<dt><strong><code>height</code></strong></dt>
<dd>widget height in pixels. If <code>None</code>, it fills the available space.</dd>
<dt><strong><code>content_gen</code></strong></dt>
<dd>Widget generator to display inside the pan-zoom widget. All events are passed
through as a return tuple member. This is a function that takes the
<a title="concur.extra_widgets.pan_zoom.TF" href="#concur.extra_widgets.pan_zoom.TF"><code>TF</code></a> object, and returns a Concur
widget. It is up to the widget to do the necessary transformations
using the <a title="concur.extra_widgets.pan_zoom.TF" href="#concur.extra_widgets.pan_zoom.TF"><code>TF</code></a> object.</dd>
<dt><strong><code>drag_tag</code></strong></dt>
<dd>The event tag for LMB drag events. If <code>None</code>, no drag events are fired.</dd>
<dt><strong><code>down_tag</code></strong></dt>
<dd>The event tag for LMB down events. If <code>None</code>, no down events are fired.
Useful in combination with <code>drag_tag</code> to indicate when the dragging started.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>To</code> <code>ease</code> <code>integration</code> <code>with</code> <code>other</code> <code>widgets</code>, <code>this</code> <code>widget</code> <code>returns</code> <code>events</code> <code>in</code> <code>a</code> <code>special</code> <code>format</code>:</dt>
<dd>&nbsp;</dd>
</dl>
<p><code>(name, state, event)</code>. <code>state</code> or <code>event</code> may be <code>None</code> in case <code>state</code> didn't change,
or there is no <code>event</code>.</p>
<p>If <code>drag_tag</code>, or <code>down_tag</code> arguments are used, these are fired in the <code>event</code> member of the return tuple.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pan_zoom(name, state, width=None, height=None, content_gen=None, drag_tag=None, down_tag=None):
    &#34;&#34;&#34; Create the Pan &amp; Zoom widget, serving as a container for a thing given by `content_gen`.

    This widget is mostly not used directly. Instead, a special-purpose wrapper can be used,
    such as `concur.extra_widgets.image.image`, or `concur.extra_widgets.frame.frame`.

    Arguments:
        name: widget name. Also serves as an event identifier
        state: `PanZoom` object representing state.
        width: widget width in pixels. If `None`, it fills the available space.
        height: widget height in pixels. If `None`, it fills the available space.
        content_gen: Widget generator to display inside the pan-zoom widget. All events are passed
            through as a return tuple member. This is a function that takes the
            `concur.extra_widgets.pan_zoom.TF` object, and returns a Concur
            widget. It is up to the widget to do the necessary transformations
            using the `TF` object.
        drag_tag: The event tag for LMB drag events. If `None`, no drag events are fired.
        down_tag: The event tag for LMB down events. If `None`, no down events are fired.
            Useful in combination with `drag_tag` to indicate when the dragging started.

    Returns:
        To ease integration with other widgets, this widget returns events in a special format:
        `(name, state, event)`. `state` or `event` may be `None` in case `state` didn&#39;t change,
        or there is no `event`.

        If `drag_tag`, or `down_tag` arguments are used, these are fired in the `event` member of the return tuple.
    &#34;&#34;&#34;
    assert content_gen is not None
    tf, content = None, None
    while True:
        assert not state.keep_aspect or not state.fix_axis, \
            &#34;Can&#39;t fix axis and keep_aspect at the same time.&#34;
        # Dynamically rescale width and height if they weren&#39;t specified
        if width is None:
            w = imgui.get_content_region_available()[0]
        else:
            w = width
        if height is None:
            h = imgui.get_content_region_available()[1]
        else:
            h = height
        frame_w = max(1, w - state.margins[0] + state.margins[2])
        frame_h = max(1, h - state.margins[1] + state.margins[3])
        w = max(1, w)
        h = max(1, h)

        zoom_x = frame_w / (state.right  - state.left)
        zoom_y = frame_h / (state.bottom - state.top)

        left, right = state.left, state.right
        top, bottom = state.top, state.bottom
        if state.keep_aspect:
            aspect = float(state.keep_aspect)
            assert state.keep_aspect &gt; 0, &#34;Negative aspect ratio is not supported.&#34;
            if abs(zoom_x) &gt; abs(zoom_y) * aspect:
                zoom_x = np.sign(zoom_x) * abs(zoom_y) * aspect
                center_x = (left + right) / 2
                left  = center_x - frame_w / zoom_x / 2
                right = center_x + frame_w / zoom_x / 2
            if abs(zoom_y) &gt; abs(zoom_x) / aspect:
                zoom_y = np.sign(zoom_y) * abs(zoom_x) / aspect
                center_y = (top + bottom) / 2
                top    = center_y - frame_h / zoom_y / 2
                bottom = center_y + frame_h / zoom_y / 2

        origin = imgui.get_cursor_screen_pos()

        imgui.begin_child(&#34;Pan-zoom&#34;, w, h, False, flags=imgui.WINDOW_NO_SCROLLBAR | imgui.WINDOW_NO_SCROLL_WITH_MOUSE) # needs to be before is_window_hovered

        # Interaction
        st = copy.deepcopy(state)
        io = imgui.get_io()
        is_window_hovered = imgui.is_window_hovered()

        if (imgui.is_mouse_clicked(1) or imgui.is_mouse_clicked(2)) and is_window_hovered:
            st.is_rmb_dragged = True
        if not (io.mouse_down[1] or io.mouse_down[2]):
            st.is_rmb_dragged = False

        delta = io.mouse_delta

        # Pan
        if st.is_rmb_dragged and (delta[0] or delta[1]):
            if st.fix_axis != &#39;x&#39;:
                st.left -= delta[0] / zoom_x
                st.right -= delta[0] / zoom_x
            if st.fix_axis != &#39;y&#39;:
                st.top -= delta[1] / zoom_y
                st.bottom -= delta[1] / zoom_y

        # Zoom
        if (imgui.is_window_hovered() or st.is_rmb_dragged) and io.mouse_wheel:
            factor = 1.3 ** io.mouse_wheel

            if st.fix_axis != &#39;x&#39;:
                mx_rel = (io.mouse_pos[0] - origin[0] - state.margins[0]) / frame_w * 2 - 1
                mx = mx_rel * (right - left) / (st.right - st.left) / 2 + 0.5
                wi = st.right - st.left
                st.left  = st.left    + wi * mx     - wi / factor * mx
                st.right = st.right   - wi * (1-mx) + wi / factor * (1-mx)

            if st.fix_axis != &#39;y&#39;:
                my_rel = (io.mouse_pos[1] - origin[1] - state.margins[1]) / frame_h * 2 - 1
                my = my_rel * (bottom - top) / (st.bottom - st.top) / 2 + 0.5
                hi = st.bottom - st.top
                st.top    = st.top    + hi * my     - hi / factor * my
                st.bottom = st.bottom - hi * (1-my) + hi / factor * (1-my)

        # Get screen-space bounds disregarding the margins
        left_s = left - st.margins[0] / zoom_x
        top_s =   top - st.margins[1] / zoom_y
        right_s = right - st.margins[2] / zoom_x
        bottom_s = bottom - st.margins[3] / zoom_y


        s2c = np.array([ # Screen to Content
            [1 / zoom_x, 0, left_s - origin[0] / zoom_x],
            [0, 1 / zoom_y, top_s  - origin[1] / zoom_y]])

        c2s = np.array([ # Content to Screen
            [zoom_x, 0, origin[0] - left_s * zoom_x],
            [0, zoom_y, origin[1] - top_s  * zoom_y]])

        view_s = [origin[0], origin[1], origin[0] + w, origin[1] + h]
        view_c = [left_s, top_s, right_s, bottom_s]

        content_value = None
        # coord_to_content = lambda x:
        try:
            new_tf = TF(c2s, s2c, view_c, view_s)
            if tf is None or tf != new_tf:
                tf = new_tf
                w, h = tf.view_s[2] - tf.view_s[0], tf.view_s[3] - tf.view_s[1]
                content = orr([
                    content_gen(tf),
                    cmap(lambda k: (k[0], [tf.s2c[0,0] * k[1].x, tf.s2c[1,1] * k[1].y]),
                        optional(drag_tag is not None,
                            draggable, drag_tag, forever(invisible_button, &#34;&#34;, w, h)
                            )
                        ),
                    ])
            next(content)
        except StopIteration as e:
            content_value = e.value
        finally:
            imgui.end_child()
        changed = st != state

        if down_tag and not st.is_rmb_dragged and imgui.is_mouse_clicked() and is_window_hovered:
            return name, (None, (down_tag, tf.inv_transform(np.array([[*io.mouse_pos]]))[0]))

        if changed or content_value is not None:
            return name, (st if changed else None, content_value)
        yield</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="concur.extra_widgets.pan_zoom.PanZoom"><code class="flex name class">
<span>class <span class="ident">PanZoom</span></span>
<span>(</span><span>top_left, bottom_right, keep_aspect=True, fix_axis=None, margins=[0, 0, 0, 0])</span>
</code></dt>
<dd>
<section class="desc"><p>Pan &amp; zoom state. </p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>top_left</code></strong></dt>
<dd>
<p>Coordinates of the top left corner of the displayed content area.</p>
</dd>
<dt><strong><code>bottom_right</code></strong></dt>
<dd>Coordinates of the bottom right corner of the displayed content area.</dd>
<dt><strong><code>keep_aspect</code></strong></dt>
<dd>Keep aspect ratio (x/y) equal to a given constant and zoom proportionally.
if keep_aspect==True, it is equivalent to keep_aspect==1.</dd>
<dt><strong><code>fix_axis</code></strong></dt>
<dd>
<p>Do not zoom in a given axis (<code>'x'</code>, <code>'y'</code>, or <code>None</code>).</p>
</dd>
<dt><strong><code>margins</code></strong></dt>
<dd>
<p>Margins (left, top, right, bottom) of the view area in pixels.
If the view area should be inset by 5 px on each side, then use
margins=[5,5,-5,-5].</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PanZoom(object):
    &#34;&#34;&#34; Pan &amp; zoom state. &#34;&#34;&#34;
    def __init__(self, top_left, bottom_right, keep_aspect=True, fix_axis=None, margins=[0, 0, 0, 0]):
        &#34;&#34;&#34;
        Arguments:
            top_left:     Coordinates of the top left corner of the displayed content area.
            bottom_right: Coordinates of the bottom right corner of the displayed content area.
            keep_aspect:  Keep aspect ratio (x/y) equal to a given constant and zoom proportionally.
                          if keep_aspect==True, it is equivalent to keep_aspect==1.
            fix_axis:     Do not zoom in a given axis (`&#39;x&#39;`, `&#39;y&#39;`, or `None`).
            margins:      Margins (left, top, right, bottom) of the view area in pixels.
                          If the view area should be inset by 5 px on each side, then use
                          margins=[5,5,-5,-5].
        &#34;&#34;&#34;
        self.reset_view(top_left, bottom_right)
         # Include cases where cursor is outside the element, but was inside when the drag started.
         # Exclude cases where cursor is inside the element, but was outside when the drag started.
        self.is_rmb_dragged = False
        self.is_lmb_dragged = False
        self.margins = margins

        self.keep_aspect = keep_aspect
        self.fix_axis = fix_axis

    def reset_view(self, top_left=None, bottom_right=None):
        &#34;&#34;&#34; Reset view to default values. &#34;&#34;&#34;
        if top_left is not None:
            self.default_left = top_left[0]
            self.default_top = top_left[1]
        if bottom_right is not None:
            self.default_right = bottom_right[0]
            self.default_bottom = bottom_right[1]
        self.top = self.default_top
        self.bottom = self.default_bottom
        self.left = self.default_left
        self.right = self.default_right

    def __eq__(self, other):
        return self.__dict__ == other.__dict__</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="concur.extra_widgets.frame.Frame" href="frame.html#concur.extra_widgets.frame.Frame">Frame</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="concur.extra_widgets.pan_zoom.PanZoom.reset_view"><code class="name flex">
<span>def <span class="ident">reset_view</span></span>(<span>self, top_left=None, bottom_right=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Reset view to default values.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_view(self, top_left=None, bottom_right=None):
    &#34;&#34;&#34; Reset view to default values. &#34;&#34;&#34;
    if top_left is not None:
        self.default_left = top_left[0]
        self.default_top = top_left[1]
    if bottom_right is not None:
        self.default_right = bottom_right[0]
        self.default_bottom = bottom_right[1]
    self.top = self.default_top
    self.bottom = self.default_bottom
    self.left = self.default_left
    self.right = self.default_right</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="concur.extra_widgets.pan_zoom.TF"><code class="flex name class">
<span>class <span class="ident">TF</span></span>
<span>(</span><span>c2s, s2c, view_c, view_s)</span>
</code></dt>
<dd>
<section class="desc"><p>Transformation object containing information necessary for converting between screen-space and image-space.</p>
<p>Screen-space coordinates are in pixels with top-left window corner equal to (0, 0). Image space is
arbitrary, given by the respective PanZoom widget state. Transformations are expressed as NumPy
matrices in homogenous coordinates with two rows and three columns (shape: <code>(2, 3)</code>).</p>
<p>For example, a point <code>[px, py]</code> can be transformed to screen-space by left multiplication:</p>
<pre><code class="python">q = np.matmul(c2s, [px, py, 1])
</code></pre>
<p>Mostly, the necessary conversions are performed by overlay widgets in <a title="concur.draw" href="../draw.html"><code>concur.draw</code></a>.
It may be useful to transform stuff by hand in cases when default behavior is not sufficient,
such as specifying the line width in image coordinates.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>c2s</code></strong></dt>
<dd>
<p>Content-to-screen transformation matrix.</p>
</dd>
<dt><strong><code>s2c</code></strong></dt>
<dd>
<p>Screen-to-content transformation matrix.</p>
</dd>
<dt><strong><code>view_s</code></strong></dt>
<dd>Screen-space viewport coordinates as a list [left, top, right, bottom].</dd>
<dt><strong><code>view_c</code></strong></dt>
<dd>Image-space viewport coordinates as a list [left, top, right, bottom].</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TF(object):
    &#34;&#34;&#34; Transformation object containing information necessary for converting between screen-space and image-space.

    Screen-space coordinates are in pixels with top-left window corner equal to (0, 0). Image space is
    arbitrary, given by the respective PanZoom widget state. Transformations are expressed as NumPy
    matrices in homogenous coordinates with two rows and three columns (shape: `(2, 3)`).

    For example, a point `[px, py]` can be transformed to screen-space by left multiplication:

    ```python
    q = np.matmul(c2s, [px, py, 1])
    ```

    Mostly, the necessary conversions are performed by overlay widgets in `concur.draw`.
    It may be useful to transform stuff by hand in cases when default behavior is not sufficient,
    such as specifying the line width in image coordinates.

    Attributes:
        c2s:      Content-to-screen transformation matrix.
        s2c:      Screen-to-content transformation matrix.
        view_s:   Screen-space viewport coordinates as a list [left, top, right, bottom].
        view_c:   Image-space viewport coordinates as a list [left, top, right, bottom].
    &#34;&#34;&#34;
    def __init__(self, c2s, s2c, view_c, view_s):
        self.c2s = c2s
        self.s2c = s2c
        self.view_c = view_c
        self.view_s = view_s

    def __eq__(self, other):
        return \
            np.array_equal(self.c2s, other.c2s) and \
            np.array_equal(self.s2c, other.s2c) and \
            self.view_c == other.view_c and \
            self.view_s == other.view_s and \
            True

    def transform(self, points):
        &#34;&#34;&#34;Transform a given NumPy array of `n` points of shape `(n, 2)` from content-space to screen-space.&#34;&#34;&#34;
        return np.tensordot(np.hstack([points, np.ones((points.shape[0], 1))]), self.c2s, (1, 1))

    def inv_transform(self, points):
        &#34;&#34;&#34;Transform a given NumPy array of `n` points of shape `(n, 2)` from screen-space to content-space.&#34;&#34;&#34;
        return np.tensordot(np.hstack([points, np.ones((points.shape[0], 1))]), self.s2c, (1, 1))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="concur.extra_widgets.pan_zoom.TF.inv_transform"><code class="name flex">
<span>def <span class="ident">inv_transform</span></span>(<span>self, points)</span>
</code></dt>
<dd>
<section class="desc"><p>Transform a given NumPy array of <code>n</code> points of shape <code>(n, 2)</code> from screen-space to content-space.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inv_transform(self, points):
    &#34;&#34;&#34;Transform a given NumPy array of `n` points of shape `(n, 2)` from screen-space to content-space.&#34;&#34;&#34;
    return np.tensordot(np.hstack([points, np.ones((points.shape[0], 1))]), self.s2c, (1, 1))</code></pre>
</details>
</dd>
<dt id="concur.extra_widgets.pan_zoom.TF.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, points)</span>
</code></dt>
<dd>
<section class="desc"><p>Transform a given NumPy array of <code>n</code> points of shape <code>(n, 2)</code> from content-space to screen-space.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform(self, points):
    &#34;&#34;&#34;Transform a given NumPy array of `n` points of shape `(n, 2)` from content-space to screen-space.&#34;&#34;&#34;
    return np.tensordot(np.hstack([points, np.ones((points.shape[0], 1))]), self.c2s, (1, 1))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="concur.extra_widgets" href="index.html">concur.extra_widgets</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="concur.extra_widgets.pan_zoom.pan_zoom" href="#concur.extra_widgets.pan_zoom.pan_zoom">pan_zoom</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="concur.extra_widgets.pan_zoom.PanZoom" href="#concur.extra_widgets.pan_zoom.PanZoom">PanZoom</a></code></h4>
<ul class="">
<li><code><a title="concur.extra_widgets.pan_zoom.PanZoom.reset_view" href="#concur.extra_widgets.pan_zoom.PanZoom.reset_view">reset_view</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="concur.extra_widgets.pan_zoom.TF" href="#concur.extra_widgets.pan_zoom.TF">TF</a></code></h4>
<ul class="">
<li><code><a title="concur.extra_widgets.pan_zoom.TF.inv_transform" href="#concur.extra_widgets.pan_zoom.TF.inv_transform">inv_transform</a></code></li>
<li><code><a title="concur.extra_widgets.pan_zoom.TF.transform" href="#concur.extra_widgets.pan_zoom.TF.transform">transform</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>