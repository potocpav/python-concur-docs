<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>concur.draw API documentation</title>
<meta name="description" content="Passive geometric shape widgets to be drawn as `concur.extra_widgets.image.image` or `concur.extra_widgets.frame.frame` overlay, or on their own …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>concur.draw</code></h1>
</header>
<section id="section-intro">
<p>Passive geometric shape widgets to be drawn as <a title="concur.extra_widgets.image.image" href="extra_widgets/image.html#concur.extra_widgets.image.image"><code>image()</code></a> or <a title="concur.extra_widgets.frame.frame" href="extra_widgets/frame.html#concur.extra_widgets.frame.frame"><code>frame()</code></a> overlay, or on their own.</p>
<p>All these widgets have the following in common:</p>
<ul>
<li>They are passive, so they don't need names. For active overlay, use normal widgets, such as buttons, wrapped inside <a title="concur.widgets.transform" href="widgets.html#concur.widgets.transform"><code>transform()</code></a>.</li>
<li>They don't do automatic layout. Instead the exact position is specified by hand.</li>
<li>Color can be specified in several ways:<ul>
<li>RGBA tuple with values between 0 and 1. For example, <code>(0.5, 0.5, 1, 1)</code> is light blue.</li>
<li>RGB tuple with values between 0 and 1. The result is opaque.</li>
<li>String specifying a color from the <a href="https://xkcd.com/color/rgb/">xkcd color set</a>, for example, <code>'red'</code>.</li>
<li><code>(str, float)</code> pair, where the first element specifies color, and the second element specifies alpha.</li>
<li>A single <code>int</code>, specifying ABGR color. For example, <code>0xffaa0000</code> is dark blue.</li>
</ul>
</li>
<li><code>tf</code> is the <a title="concur.extra_widgets.pan_zoom.TF" href="extra_widgets/pan_zoom.html#concur.extra_widgets.pan_zoom.TF"><code>TF</code></a> object specifying transformations from screen-space to image-space and back.
If no transformation is supplied, the element is drawn in screen space units.</li>
</ul>
<p>Theses widgets are not re-exported in the root module, and are normally used as <code>c.draw.line(...)</code>, etc.
They can be composed normally using the <a title="concur.core.orr" href="core.html#concur.core.orr"><code>orr()</code></a> function.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; Passive geometric shape widgets to be drawn as `concur.extra_widgets.image.image` or `concur.extra_widgets.frame.frame` overlay, or on their own.

All these widgets have the following in common:

* They are passive, so they don&#39;t need names. For active overlay, use normal widgets, such as buttons, wrapped inside `concur.widgets.transform`.
* They don&#39;t do automatic layout. Instead the exact position is specified by hand.
* Color can be specified in several ways:
    * RGBA tuple with values between 0 and 1. For example, `(0.5, 0.5, 1, 1)` is light blue.
    * RGB tuple with values between 0 and 1. The result is opaque.
    * String specifying a color from the [xkcd color set](https://xkcd.com/color/rgb/), for example, `&#39;red&#39;`.
    * `(str, float)` pair, where the first element specifies color, and the second element specifies alpha.
    * A single `int`, specifying ABGR color. For example, `0xffaa0000` is dark blue.
* `tf` is the `concur.extra_widgets.pan_zoom.TF` object specifying transformations from screen-space to image-space and back.
  If no transformation is supplied, the element is drawn in screen space units.

Theses widgets are not re-exported in the root module, and are normally used as `c.draw.line(...)`, etc.
They can be composed normally using the `concur.core.orr` function.
&#34;&#34;&#34;

import numpy as np
import imgui
from concur.colors import color_to_rgba
from concur.core import nothing

__pdoc__ = dict(prepare_polyline_points=False)


def line(x0, y0, x1, y1, color, thickness=1, tf=None):
    &#34;&#34;&#34; Line connecting two points. &#34;&#34;&#34;
    if tf is not None:
        [x0, y0], [x1, y1] = tf.transform(np.array([[x0, y0], [x1, y1]]))
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_line(x0, y0, x1, y1, col, thickness)
        yield


def rect(x0, y0, x1, y1, color, thickness=1, rounding=0, tf=None):
    &#34;&#34;&#34; Straight non-filled rectangle specified by its two corners. &#34;&#34;&#34;
    if tf is not None:
        [x0, y0], [x1, y1] = tf.transform(np.array([[x0, y0], [x1, y1]]))
    # Avoid issues with disappearing lines on very large rectangles
    x0, x1 = np.clip([x0, x1], -8192, 8192)
    y0, y1 = np.clip([y0, y1], -8192, 8192)
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_rect(x0, y0, x1, y1, col, rounding, 15 if rounding else 0, thickness)
        yield


def rects(rects, color, thickness=1, tf=None):
    &#34;&#34;&#34; Multiple straight non-filled rectangles specified by their two corners.

    `rects` is a NumPy array of shape `(n, 4)`, where `n` is the number of rectangles.
    &#34;&#34;&#34;
    if len(rects) == 0:
        while True:
            yield
    if tf is not None:
        rects = tf.transform(rects.reshape(-1, 2)).reshape(rects.shape)
    # Avoid issues with disappearing lines on very large rectangles
    rects = np.clip(rects, -8192, 8192)
    polys = np.empty((len(rects), 4, 2), dtype=rects.dtype)
    polys[:,0] = rects[:,:2]
    polys[:,1,0] = rects[:,0]
    polys[:,1,1] = rects[:,3]
    polys[:,2] = rects[:,2:]
    polys[:,3,0] = rects[:,2]
    polys[:,3,1] = rects[:,1]
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_polylines(polys, col, True, thickness)
        yield


def rect_filled(x0, y0, x1, y1, color, rounding=0, tf=None):
    &#34;&#34;&#34; Straight non-filled rectangle specified by its two corners. &#34;&#34;&#34;
    if tf is not None:
        [x0, y0], [x1, y1] = tf.transform(np.array([[x0, y0], [x1, y1]]))
    # Avoid issues with disappearing lines on very large rectangles
    x0, x1 = np.clip([x0, x1], -8192, 8192)
    y0, y1 = np.clip([y0, y1], -8192, 8192)
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_rect_filled(x0, y0, x1, y1, col, rounding, 15 if rounding else 0)
        yield


def circle(cx, cy, radius, color, thickness=1, num_segments=16, tf=None):
    &#34;&#34;&#34; Circle specified by its center and radius. &#34;&#34;&#34;
    if tf is not None:
        assert np.allclose(np.abs(tf.c2s[0,0]), np.abs(tf.c2s[1,1])), \
            &#34;`tf` must be aspect ratio preserving to draw circles. Use `ellipse` instead, if it isn&#39;t the case.&#34;
        [cx, cy], radius = np.matmul(tf.c2s, [cx, cy, 1]), radius * tf.c2s[0,0]
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_circle(cx, cy, radius, col, num_segments=num_segments, thickness=thickness)
        yield


def prepare_polyline_points(points, tf):
    if len(points) == 0:
        return np.zeros((0, 2))
    if not isinstance(points, np.ndarray):
        points = np.array(points)
    if tf is not None:
        points = tf.transform(points)
    return points


def polyline(points, color, closed=False, thickness=1, tf=None):
    &#34;&#34;&#34; Polygonal line or a closed polygon.

    `points` is a list of (x, y) tuples, or a NumPy array of equivalent shape.
    &#34;&#34;&#34;
    points = prepare_polyline_points(points, tf)
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_polyline(points, col, closed, thickness)
        yield


def polygon(points, color, tf=None):
    &#34;&#34;&#34; Filled polygon. Points must form a convex area.

    `points` is a list of (x, y) tuples, or a NumPy array of equivalent shape.
    &#34;&#34;&#34;
    points = prepare_polyline_points(points, tf)
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_convex_poly_filled(points, col)
        yield


def polylines(points, color, closed=False, thickness=1, tf=None):
    &#34;&#34;&#34; Multiple polygonal lines with the same length and parameters.

    Calling this function is more efficient than calling `polyline` multiple times, because all the data is given
    to the C++ back-end in one Python call, and because transformation is vectorized.

    `points` is a NumPy array with shape `(n, m, 2)`, where `n` is the number of polylines, and `m` is the number of points
    in each polyline.
    &#34;&#34;&#34;
    if len(points) == 0:
        while True:
            yield
    if tf is not None:
        points = tf.transform(points.reshape(-1, 2)).reshape(points.shape)
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_polylines(points, col, closed, thickness)
        yield


def polygons(points, color, tf=None):
    &#34;&#34;&#34; Multiple filled polygons with the same length and color.

    Calling this function is more efficient than calling `polygon` multiple times, because all the data is given
    to the C++ back-end in one Python call, and because transformation is vectorized.

    `points` is a NumPy array with shape `(n, m, 2)`, where `n` is the number of polygons, and `m` is the number of points
    in each polyline.
    &#34;&#34;&#34;
    if tf is not None:
        points = tf.transform(points.reshape(-1, 2)).reshape(points.shape)
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_convex_polys_filled(points, col)
        yield


def text(string, x, y, color, tf=None):
    &#34;&#34;&#34; Text, using the default font and font size.

    This is a raw drawing function. Use `concur.widgets.text` instead if you want a text widget.
    &#34;&#34;&#34;
    if tf is not None:
        x, y = np.matmul(tf.c2s, [x, y, 1])
    col = color_to_rgba(color)
    while True:
        # Text was hanging the application if too far away
        if -8192 &lt; x &lt; 8192 and -8192 &lt; y &lt; 8192:
            draw_list = imgui.get_window_draw_list()
            draw_list.add_text(x, y, col, string)
        yield


def image(tex_id, w, h, tf):
    &#34;&#34;&#34; Draw an image with the given width and height.

    This is a raw drawing function. Use `concur.extra_widgets.image.image` instead if you want an image widget.
    &#34;&#34;&#34;
    x0, y0, x1, y1 = 0, 0, w, h
    if tf is not None:
        [x0, y0], [x1, y1] = tf.transform(np.array([[x0, y0], [x1, y1]]))
    draw_list = imgui.get_window_draw_list()
    l, t, r, b = tf.view_s
    a_s = tf.view_s[:2]
    b_s = tf.view_s[2:]
    a_i = tf.view_c[0] / w, tf.view_c[1] / h
    b_i = tf.view_c[2] / w, tf.view_c[3] / h
    while True:
        draw_list.add_image(tex_id, tuple(a_s), tuple(b_s), tuple(a_i), tuple(b_i))
        yield


def ellipse(mean, cov, sd, color, thickness=1, num_segments=16, tf=None):
    &#34;Ellipse defined by a mean, covariance matrix, and SD.&#34;
    [e1, e2], vs = np.linalg.eig(cov)
    assert e1 &gt; 0 and e2 &gt; 0, &#34;cov must be positive-semidefinite&#34;
    v1, v2 = vs.T
    t = np.linspace(0, np.pi*2, num_segments, endpoint=False).reshape(-1, 1)
    el = v1 * np.sin(t) * np.sqrt(e1) * sd + v2 * np.cos(t) * np.sqrt(e2) * sd
    return polyline(el + mean, color, True, thickness, tf=tf)


def ellipses(means, covs, sd, color, thickness=1, num_segments=16, tf=None):
    &#34;&#34;&#34;Multiple ellipses defined by a means, covariance matrices, and SD.

    The call is very similar to `ellipse`, but `mean` and `cov` are vectorized: there is one more dimension (zeroth) for both.
    For `n` ellipses, the shape of `mean` is `(n, 2)`, and the shape of `cov` is `(n, 2, 2)`.
    &#34;&#34;&#34;
    if len(means) == 0 and len(covs) == 0:
        return nothing()
    assert len(means) == len(covs)
    assert len(means.shape) == 2 and means.shape[1] == 2
    assert len(covs.shape) == 3 and covs.shape[1] == 2 and covs.shape[2] == 2
    es, vs = np.linalg.eig(covs)
    assert np.all(es &gt; 0), &#34;covariance matrices must be positive-semidefinite&#34;
    v1 = vs[...,0].reshape(-1, 1, 2)
    v2 = vs[...,1].reshape(-1, 1, 2)
    e1 = es[:,0].reshape(-1, 1, 1)
    e2 = es[:,1].reshape(-1, 1, 1)
    t = np.linspace(0, np.pi*2, num_segments, endpoint=False).reshape(-1, 1)
    el = v1 * np.sin(t) * np.sqrt(e1) * sd + v2 * np.cos(t) * np.sqrt(e2) * sd
    return polylines(el + means.reshape(-1, 1, 2), color, True, thickness, tf=tf)


def scatter(pts, color, marker, marker_size=10, thickness=1, tf=None):
    &#34;&#34;&#34;Draw a scatter plot with given marker settings.

    If multiple settings are desired (such as two distinct point colors), call
    this function more than once with different parameters.

    Some markers are more performant than others, depending on the amount of
    generated geometry.

    Arguments:
      pts: NumPy array with shape `(n, 2)`, where `n` is the point count.
      color: Color to draw the markers.
      marker: Marker type. See the table below.
      marker_size: Size of the markers in pixels.
      thickness: Line width for non-filled markers
    ------
    marker | description
    ------ | ---
    `&#34;.&#34;`  | filled square
    `&#34;x&#34;`  | cross
    `&#34;+&#34;`  | plus sign
    `&#34;o&#34;`  | non-filled circle
    `&#34;s&#34;`  | non-filled square
    &#34;&#34;&#34;
    if len(pts) == 0:
        pts = pts.reshape(-1, 2)
    assert len(pts.shape) == 2 and pts.shape[1] == 2
    if tf is not None:
        pts = tf.transform(pts)

    if marker == &#39;.&#39;:
        r = marker_size / 2
        polys = np.empty((len(pts), 4, 2))
        polys[:, 0, :] = pts + [-r, -r]
        polys[:, 1, :] = pts + [ r, -r]
        polys[:, 2, :] = pts + [ r,  r]
        polys[:, 3, :] = pts + [-r,  r]
        return polygons(polys, color)
    elif marker == &#39;+&#39;:
        r = marker_size / 2
        polys = np.empty((len(pts) * 2, 2, 2))
        polys[0::2, 0, :] = pts - [r, 0]
        polys[0::2, 1, :] = pts + [r, 0]
        polys[1::2, 0, :] = pts - [0, r]
        polys[1::2, 1, :] = pts + [0, r]
        return polylines(polys, color, False, thickness)
    elif marker in [&#39;X&#39;, &#39;x&#39;, &#39;×&#39;]:
        r = marker_size / np.sqrt(8)
        polys = np.empty((len(pts) * 2, 2, 2))
        polys[0::2, 0, :] = pts - [r, r]
        polys[0::2, 1, :] = pts + [r, r]
        polys[1::2, 0, :] = pts - [-r, r]
        polys[1::2, 1, :] = pts + [-r, r]
        return polylines(polys, color, False, thickness)
    elif marker in [&#39;O&#39;, &#39;o&#39;]:
        r = marker_size / 2
        n_verts = 7
        t = np.linspace(0, np.pi * 2, n_verts, endpoint=False)
        polys = np.empty((len(pts), n_verts, 2))
        polys[...,0] = np.sin(t) * r
        polys[...,1] = np.cos(t) * r
        polys += pts.reshape(-1, 1, 2)
        return polylines(polys, color, True, thickness)
    elif marker in [&#39;s&#39;, &#39;S&#39;]:
        r = marker_size / 2
        t = np.pi/4 + np.linspace(0, np.pi * 2, 4, endpoint=False)
        polys = np.empty((len(pts), 4, 2))
        polys[...,0] = np.sin(t) * r
        polys[...,1] = np.cos(t) * r
        polys += pts.reshape(-1, 1, 2)
        return polylines(polys, color, True, thickness)
    else:
        raise ValueError(&#39;Invalid marker&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="concur.draw.circle"><code class="name flex">
<span>def <span class="ident">circle</span></span>(<span>cx, cy, radius, color, thickness=1, num_segments=16, tf=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Circle specified by its center and radius.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def circle(cx, cy, radius, color, thickness=1, num_segments=16, tf=None):
    &#34;&#34;&#34; Circle specified by its center and radius. &#34;&#34;&#34;
    if tf is not None:
        assert np.allclose(np.abs(tf.c2s[0,0]), np.abs(tf.c2s[1,1])), \
            &#34;`tf` must be aspect ratio preserving to draw circles. Use `ellipse` instead, if it isn&#39;t the case.&#34;
        [cx, cy], radius = np.matmul(tf.c2s, [cx, cy, 1]), radius * tf.c2s[0,0]
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_circle(cx, cy, radius, col, num_segments=num_segments, thickness=thickness)
        yield</code></pre>
</details>
</dd>
<dt id="concur.draw.ellipse"><code class="name flex">
<span>def <span class="ident">ellipse</span></span>(<span>mean, cov, sd, color, thickness=1, num_segments=16, tf=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Ellipse defined by a mean, covariance matrix, and SD.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ellipse(mean, cov, sd, color, thickness=1, num_segments=16, tf=None):
    &#34;Ellipse defined by a mean, covariance matrix, and SD.&#34;
    [e1, e2], vs = np.linalg.eig(cov)
    assert e1 &gt; 0 and e2 &gt; 0, &#34;cov must be positive-semidefinite&#34;
    v1, v2 = vs.T
    t = np.linspace(0, np.pi*2, num_segments, endpoint=False).reshape(-1, 1)
    el = v1 * np.sin(t) * np.sqrt(e1) * sd + v2 * np.cos(t) * np.sqrt(e2) * sd
    return polyline(el + mean, color, True, thickness, tf=tf)</code></pre>
</details>
</dd>
<dt id="concur.draw.ellipses"><code class="name flex">
<span>def <span class="ident">ellipses</span></span>(<span>means, covs, sd, color, thickness=1, num_segments=16, tf=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Multiple ellipses defined by a means, covariance matrices, and SD.</p>
<p>The call is very similar to <a title="concur.draw.ellipse" href="#concur.draw.ellipse"><code>ellipse()</code></a>, but <code>mean</code> and <code>cov</code> are vectorized: there is one more dimension (zeroth) for both.
For <code>n</code> ellipses, the shape of <code>mean</code> is <code>(n, 2)</code>, and the shape of <code>cov</code> is <code>(n, 2, 2)</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ellipses(means, covs, sd, color, thickness=1, num_segments=16, tf=None):
    &#34;&#34;&#34;Multiple ellipses defined by a means, covariance matrices, and SD.

    The call is very similar to `ellipse`, but `mean` and `cov` are vectorized: there is one more dimension (zeroth) for both.
    For `n` ellipses, the shape of `mean` is `(n, 2)`, and the shape of `cov` is `(n, 2, 2)`.
    &#34;&#34;&#34;
    if len(means) == 0 and len(covs) == 0:
        return nothing()
    assert len(means) == len(covs)
    assert len(means.shape) == 2 and means.shape[1] == 2
    assert len(covs.shape) == 3 and covs.shape[1] == 2 and covs.shape[2] == 2
    es, vs = np.linalg.eig(covs)
    assert np.all(es &gt; 0), &#34;covariance matrices must be positive-semidefinite&#34;
    v1 = vs[...,0].reshape(-1, 1, 2)
    v2 = vs[...,1].reshape(-1, 1, 2)
    e1 = es[:,0].reshape(-1, 1, 1)
    e2 = es[:,1].reshape(-1, 1, 1)
    t = np.linspace(0, np.pi*2, num_segments, endpoint=False).reshape(-1, 1)
    el = v1 * np.sin(t) * np.sqrt(e1) * sd + v2 * np.cos(t) * np.sqrt(e2) * sd
    return polylines(el + means.reshape(-1, 1, 2), color, True, thickness, tf=tf)</code></pre>
</details>
</dd>
<dt id="concur.draw.image"><code class="name flex">
<span>def <span class="ident">image</span></span>(<span>tex_id, w, h, tf)</span>
</code></dt>
<dd>
<section class="desc"><p>Draw an image with the given width and height.</p>
<p>This is a raw drawing function. Use <a title="concur.extra_widgets.image.image" href="extra_widgets/image.html#concur.extra_widgets.image.image"><code>image()</code></a> instead if you want an image widget.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def image(tex_id, w, h, tf):
    &#34;&#34;&#34; Draw an image with the given width and height.

    This is a raw drawing function. Use `concur.extra_widgets.image.image` instead if you want an image widget.
    &#34;&#34;&#34;
    x0, y0, x1, y1 = 0, 0, w, h
    if tf is not None:
        [x0, y0], [x1, y1] = tf.transform(np.array([[x0, y0], [x1, y1]]))
    draw_list = imgui.get_window_draw_list()
    l, t, r, b = tf.view_s
    a_s = tf.view_s[:2]
    b_s = tf.view_s[2:]
    a_i = tf.view_c[0] / w, tf.view_c[1] / h
    b_i = tf.view_c[2] / w, tf.view_c[3] / h
    while True:
        draw_list.add_image(tex_id, tuple(a_s), tuple(b_s), tuple(a_i), tuple(b_i))
        yield</code></pre>
</details>
</dd>
<dt id="concur.draw.line"><code class="name flex">
<span>def <span class="ident">line</span></span>(<span>x0, y0, x1, y1, color, thickness=1, tf=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Line connecting two points.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def line(x0, y0, x1, y1, color, thickness=1, tf=None):
    &#34;&#34;&#34; Line connecting two points. &#34;&#34;&#34;
    if tf is not None:
        [x0, y0], [x1, y1] = tf.transform(np.array([[x0, y0], [x1, y1]]))
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_line(x0, y0, x1, y1, col, thickness)
        yield</code></pre>
</details>
</dd>
<dt id="concur.draw.polygon"><code class="name flex">
<span>def <span class="ident">polygon</span></span>(<span>points, color, tf=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Filled polygon. Points must form a convex area.</p>
<p><code>points</code> is a list of (x, y) tuples, or a NumPy array of equivalent shape.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polygon(points, color, tf=None):
    &#34;&#34;&#34; Filled polygon. Points must form a convex area.

    `points` is a list of (x, y) tuples, or a NumPy array of equivalent shape.
    &#34;&#34;&#34;
    points = prepare_polyline_points(points, tf)
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_convex_poly_filled(points, col)
        yield</code></pre>
</details>
</dd>
<dt id="concur.draw.polygons"><code class="name flex">
<span>def <span class="ident">polygons</span></span>(<span>points, color, tf=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Multiple filled polygons with the same length and color.</p>
<p>Calling this function is more efficient than calling <a title="concur.draw.polygon" href="#concur.draw.polygon"><code>polygon()</code></a> multiple times, because all the data is given
to the C++ back-end in one Python call, and because transformation is vectorized.</p>
<p><code>points</code> is a NumPy array with shape <code>(n, m, 2)</code>, where <code>n</code> is the number of polygons, and <code>m</code> is the number of points
in each polyline.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polygons(points, color, tf=None):
    &#34;&#34;&#34; Multiple filled polygons with the same length and color.

    Calling this function is more efficient than calling `polygon` multiple times, because all the data is given
    to the C++ back-end in one Python call, and because transformation is vectorized.

    `points` is a NumPy array with shape `(n, m, 2)`, where `n` is the number of polygons, and `m` is the number of points
    in each polyline.
    &#34;&#34;&#34;
    if tf is not None:
        points = tf.transform(points.reshape(-1, 2)).reshape(points.shape)
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_convex_polys_filled(points, col)
        yield</code></pre>
</details>
</dd>
<dt id="concur.draw.polyline"><code class="name flex">
<span>def <span class="ident">polyline</span></span>(<span>points, color, closed=False, thickness=1, tf=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Polygonal line or a closed polygon.</p>
<p><code>points</code> is a list of (x, y) tuples, or a NumPy array of equivalent shape.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polyline(points, color, closed=False, thickness=1, tf=None):
    &#34;&#34;&#34; Polygonal line or a closed polygon.

    `points` is a list of (x, y) tuples, or a NumPy array of equivalent shape.
    &#34;&#34;&#34;
    points = prepare_polyline_points(points, tf)
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_polyline(points, col, closed, thickness)
        yield</code></pre>
</details>
</dd>
<dt id="concur.draw.polylines"><code class="name flex">
<span>def <span class="ident">polylines</span></span>(<span>points, color, closed=False, thickness=1, tf=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Multiple polygonal lines with the same length and parameters.</p>
<p>Calling this function is more efficient than calling <a title="concur.draw.polyline" href="#concur.draw.polyline"><code>polyline()</code></a> multiple times, because all the data is given
to the C++ back-end in one Python call, and because transformation is vectorized.</p>
<p><code>points</code> is a NumPy array with shape <code>(n, m, 2)</code>, where <code>n</code> is the number of polylines, and <code>m</code> is the number of points
in each polyline.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polylines(points, color, closed=False, thickness=1, tf=None):
    &#34;&#34;&#34; Multiple polygonal lines with the same length and parameters.

    Calling this function is more efficient than calling `polyline` multiple times, because all the data is given
    to the C++ back-end in one Python call, and because transformation is vectorized.

    `points` is a NumPy array with shape `(n, m, 2)`, where `n` is the number of polylines, and `m` is the number of points
    in each polyline.
    &#34;&#34;&#34;
    if len(points) == 0:
        while True:
            yield
    if tf is not None:
        points = tf.transform(points.reshape(-1, 2)).reshape(points.shape)
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_polylines(points, col, closed, thickness)
        yield</code></pre>
</details>
</dd>
<dt id="concur.draw.rect"><code class="name flex">
<span>def <span class="ident">rect</span></span>(<span>x0, y0, x1, y1, color, thickness=1, rounding=0, tf=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Straight non-filled rectangle specified by its two corners.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rect(x0, y0, x1, y1, color, thickness=1, rounding=0, tf=None):
    &#34;&#34;&#34; Straight non-filled rectangle specified by its two corners. &#34;&#34;&#34;
    if tf is not None:
        [x0, y0], [x1, y1] = tf.transform(np.array([[x0, y0], [x1, y1]]))
    # Avoid issues with disappearing lines on very large rectangles
    x0, x1 = np.clip([x0, x1], -8192, 8192)
    y0, y1 = np.clip([y0, y1], -8192, 8192)
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_rect(x0, y0, x1, y1, col, rounding, 15 if rounding else 0, thickness)
        yield</code></pre>
</details>
</dd>
<dt id="concur.draw.rect_filled"><code class="name flex">
<span>def <span class="ident">rect_filled</span></span>(<span>x0, y0, x1, y1, color, rounding=0, tf=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Straight non-filled rectangle specified by its two corners.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rect_filled(x0, y0, x1, y1, color, rounding=0, tf=None):
    &#34;&#34;&#34; Straight non-filled rectangle specified by its two corners. &#34;&#34;&#34;
    if tf is not None:
        [x0, y0], [x1, y1] = tf.transform(np.array([[x0, y0], [x1, y1]]))
    # Avoid issues with disappearing lines on very large rectangles
    x0, x1 = np.clip([x0, x1], -8192, 8192)
    y0, y1 = np.clip([y0, y1], -8192, 8192)
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_rect_filled(x0, y0, x1, y1, col, rounding, 15 if rounding else 0)
        yield</code></pre>
</details>
</dd>
<dt id="concur.draw.rects"><code class="name flex">
<span>def <span class="ident">rects</span></span>(<span>rects, color, thickness=1, tf=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Multiple straight non-filled rectangles specified by their two corners.</p>
<p><a title="concur.draw.rects" href="#concur.draw.rects"><code>rects()</code></a> is a NumPy array of shape <code>(n, 4)</code>, where <code>n</code> is the number of rectangles.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rects(rects, color, thickness=1, tf=None):
    &#34;&#34;&#34; Multiple straight non-filled rectangles specified by their two corners.

    `rects` is a NumPy array of shape `(n, 4)`, where `n` is the number of rectangles.
    &#34;&#34;&#34;
    if len(rects) == 0:
        while True:
            yield
    if tf is not None:
        rects = tf.transform(rects.reshape(-1, 2)).reshape(rects.shape)
    # Avoid issues with disappearing lines on very large rectangles
    rects = np.clip(rects, -8192, 8192)
    polys = np.empty((len(rects), 4, 2), dtype=rects.dtype)
    polys[:,0] = rects[:,:2]
    polys[:,1,0] = rects[:,0]
    polys[:,1,1] = rects[:,3]
    polys[:,2] = rects[:,2:]
    polys[:,3,0] = rects[:,2]
    polys[:,3,1] = rects[:,1]
    draw_list = imgui.get_window_draw_list()
    col = color_to_rgba(color)
    while True:
        draw_list.add_polylines(polys, col, True, thickness)
        yield</code></pre>
</details>
</dd>
<dt id="concur.draw.scatter"><code class="name flex">
<span>def <span class="ident">scatter</span></span>(<span>pts, color, marker, marker_size=10, thickness=1, tf=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Draw a scatter plot with given marker settings.</p>
<p>If multiple settings are desired (such as two distinct point colors), call
this function more than once with different parameters.</p>
<p>Some markers are more performant than others, depending on the amount of
generated geometry.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>pts</code></strong></dt>
<dd>NumPy array with shape <code>(n, 2)</code>, where <code>n</code> is the point count.</dd>
<dt><strong><code>color</code></strong></dt>
<dd>Color to draw the markers.</dd>
<dt><strong><code>marker</code></strong></dt>
<dd>Marker type. See the table below.</dd>
<dt><strong><code>marker_size</code></strong></dt>
<dd>Size of the markers in pixels.</dd>
<dt><strong><code>thickness</code></strong></dt>
<dd>Line width for non-filled markers</dd>
</dl>
<hr>
<table>
<thead>
<tr>
<th>marker</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>"."</code></td>
<td>filled square</td>
</tr>
<tr>
<td><code>"x"</code></td>
<td>cross</td>
</tr>
<tr>
<td><code>"+"</code></td>
<td>plus sign</td>
</tr>
<tr>
<td><code>"o"</code></td>
<td>non-filled circle</td>
</tr>
<tr>
<td><code>"s"</code></td>
<td>non-filled square</td>
</tr>
</tbody>
</table></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scatter(pts, color, marker, marker_size=10, thickness=1, tf=None):
    &#34;&#34;&#34;Draw a scatter plot with given marker settings.

    If multiple settings are desired (such as two distinct point colors), call
    this function more than once with different parameters.

    Some markers are more performant than others, depending on the amount of
    generated geometry.

    Arguments:
      pts: NumPy array with shape `(n, 2)`, where `n` is the point count.
      color: Color to draw the markers.
      marker: Marker type. See the table below.
      marker_size: Size of the markers in pixels.
      thickness: Line width for non-filled markers
    ------
    marker | description
    ------ | ---
    `&#34;.&#34;`  | filled square
    `&#34;x&#34;`  | cross
    `&#34;+&#34;`  | plus sign
    `&#34;o&#34;`  | non-filled circle
    `&#34;s&#34;`  | non-filled square
    &#34;&#34;&#34;
    if len(pts) == 0:
        pts = pts.reshape(-1, 2)
    assert len(pts.shape) == 2 and pts.shape[1] == 2
    if tf is not None:
        pts = tf.transform(pts)

    if marker == &#39;.&#39;:
        r = marker_size / 2
        polys = np.empty((len(pts), 4, 2))
        polys[:, 0, :] = pts + [-r, -r]
        polys[:, 1, :] = pts + [ r, -r]
        polys[:, 2, :] = pts + [ r,  r]
        polys[:, 3, :] = pts + [-r,  r]
        return polygons(polys, color)
    elif marker == &#39;+&#39;:
        r = marker_size / 2
        polys = np.empty((len(pts) * 2, 2, 2))
        polys[0::2, 0, :] = pts - [r, 0]
        polys[0::2, 1, :] = pts + [r, 0]
        polys[1::2, 0, :] = pts - [0, r]
        polys[1::2, 1, :] = pts + [0, r]
        return polylines(polys, color, False, thickness)
    elif marker in [&#39;X&#39;, &#39;x&#39;, &#39;×&#39;]:
        r = marker_size / np.sqrt(8)
        polys = np.empty((len(pts) * 2, 2, 2))
        polys[0::2, 0, :] = pts - [r, r]
        polys[0::2, 1, :] = pts + [r, r]
        polys[1::2, 0, :] = pts - [-r, r]
        polys[1::2, 1, :] = pts + [-r, r]
        return polylines(polys, color, False, thickness)
    elif marker in [&#39;O&#39;, &#39;o&#39;]:
        r = marker_size / 2
        n_verts = 7
        t = np.linspace(0, np.pi * 2, n_verts, endpoint=False)
        polys = np.empty((len(pts), n_verts, 2))
        polys[...,0] = np.sin(t) * r
        polys[...,1] = np.cos(t) * r
        polys += pts.reshape(-1, 1, 2)
        return polylines(polys, color, True, thickness)
    elif marker in [&#39;s&#39;, &#39;S&#39;]:
        r = marker_size / 2
        t = np.pi/4 + np.linspace(0, np.pi * 2, 4, endpoint=False)
        polys = np.empty((len(pts), 4, 2))
        polys[...,0] = np.sin(t) * r
        polys[...,1] = np.cos(t) * r
        polys += pts.reshape(-1, 1, 2)
        return polylines(polys, color, True, thickness)
    else:
        raise ValueError(&#39;Invalid marker&#39;)</code></pre>
</details>
</dd>
<dt id="concur.draw.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>string, x, y, color, tf=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Text, using the default font and font size.</p>
<p>This is a raw drawing function. Use <a title="concur.widgets.text" href="widgets.html#concur.widgets.text"><code>text()</code></a> instead if you want a text widget.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def text(string, x, y, color, tf=None):
    &#34;&#34;&#34; Text, using the default font and font size.

    This is a raw drawing function. Use `concur.widgets.text` instead if you want a text widget.
    &#34;&#34;&#34;
    if tf is not None:
        x, y = np.matmul(tf.c2s, [x, y, 1])
    col = color_to_rgba(color)
    while True:
        # Text was hanging the application if too far away
        if -8192 &lt; x &lt; 8192 and -8192 &lt; y &lt; 8192:
            draw_list = imgui.get_window_draw_list()
            draw_list.add_text(x, y, col, string)
        yield</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="concur" href="index.html">concur</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="concur.draw.circle" href="#concur.draw.circle">circle</a></code></li>
<li><code><a title="concur.draw.ellipse" href="#concur.draw.ellipse">ellipse</a></code></li>
<li><code><a title="concur.draw.ellipses" href="#concur.draw.ellipses">ellipses</a></code></li>
<li><code><a title="concur.draw.image" href="#concur.draw.image">image</a></code></li>
<li><code><a title="concur.draw.line" href="#concur.draw.line">line</a></code></li>
<li><code><a title="concur.draw.polygon" href="#concur.draw.polygon">polygon</a></code></li>
<li><code><a title="concur.draw.polygons" href="#concur.draw.polygons">polygons</a></code></li>
<li><code><a title="concur.draw.polyline" href="#concur.draw.polyline">polyline</a></code></li>
<li><code><a title="concur.draw.polylines" href="#concur.draw.polylines">polylines</a></code></li>
<li><code><a title="concur.draw.rect" href="#concur.draw.rect">rect</a></code></li>
<li><code><a title="concur.draw.rect_filled" href="#concur.draw.rect_filled">rect_filled</a></code></li>
<li><code><a title="concur.draw.rects" href="#concur.draw.rects">rects</a></code></li>
<li><code><a title="concur.draw.scatter" href="#concur.draw.scatter">scatter</a></code></li>
<li><code><a title="concur.draw.text" href="#concur.draw.text">text</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>