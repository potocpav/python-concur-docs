URLS=[
"index.html",
"extra_widgets/index.html",
"extra_widgets/draggable.html",
"extra_widgets/frame.html",
"extra_widgets/pan_zoom.html",
"extra_widgets/image.html",
"integrations/index.html",
"integrations/opengl.html",
"integrations/quick.html",
"integrations/puppet.html",
"integrations/glfw.html",
"testing.html",
"colors.html",
"core.html",
"draw.html",
"widgets.html"
];
INDEX=[
{
"ref":"concur",
"url":0,
"doc":"Most of the functions and classes from submodules are re-exported in the  concur root module. The idiomatic way to access them is by importing  concur qualified:   import concur as c  nearly anything can be accessed using  c.anything now.   A notable exception is the  concur.draw functions: they have a bit different semantics, so they are in a separate module,  c.draw ."
},
{
"ref":"concur.partial",
"url":0,
"doc":"Re-export of [ functools.partial ](https: docs.python.org/3.9/library/functools.html functools.partial) for convenience",
"func":1
},
{
"ref":"concur.extra_widgets",
"url":1,
"doc":"Extra widgets that do not directly correspond to ImGui calls."
},
{
"ref":"concur.extra_widgets.draggable",
"url":2,
"doc":"Add dragging functionality to any Widget. Useful for e.g. control points in images. Buttons work well as the base widget, but most graphical widgets can be used, apart from the  concur.draw ones."
},
{
"ref":"concur.extra_widgets.draggable.draggable",
"url":2,
"doc":"Add draggable functionality to a widget. Emits (dx, dy) when dragged. The underlying widget works as usual. Returned values are equal to the mouse position difference from the previous frame.",
"func":1
},
{
"ref":"concur.extra_widgets.frame",
"url":3,
"doc":"Pannable, zoomable graph area with axes and gridlines."
},
{
"ref":"concur.extra_widgets.frame.Frame",
"url":3,
"doc":"Pan & zoom state. Simple PanZoom re-export with specified margins. Args: top_left: Coordinates of the top left corner of the displayed content area. bottom_right: Coordinates of the bottom right corner of the displayed content area. keep_aspect: Keep aspect ratio (x/y) equal to a given constant and zoom proportionally. if keep_aspect True, it is equivalent to keep_aspect 1. fix_axis: Do not zoom in a given axis ( 'x' ,  'y' , or  None )."
},
{
"ref":"concur.extra_widgets.frame.Frame.reset_view",
"url":4,
"doc":"Reset view to default values.",
"func":1
},
{
"ref":"concur.extra_widgets.frame.frame",
"url":3,
"doc":"The frame widget.  state is an instance of  Frame . See the [plot example](https: github.com/potocpav/python-concur/blob/master/examples/plot.py) for an usage example. Content is specified using  content_gen , analogously to how it's done in  concur.extra_widgets.image.image .",
"func":1
},
{
"ref":"concur.extra_widgets.image",
"url":5,
"doc":"Scrollable, zoomable image widget with overlay support."
},
{
"ref":"concur.extra_widgets.image.image",
"url":5,
"doc":"The image widget. See the [image example](https: github.com/potocpav/python-concur/blob/master/examples/image.py) for a simple example usage, and the [image events example](https: github.com/potocpav/python-concur/blob/master/examples/extra/image_events.py) for an example involving event handling. It is very common to use  concur.partial to pass additional arguments to the  content_gen function:   def overlay(pos, tf): return c.draw.circle( pos, 10, (0,0,0,1), tf=tf) _, im = yield from c.image(\"Image\", im, content_gen=c.partial(overlay, pos   Args: name: Widget name, serves as the identifier for state change events state: Instance of  concur.extra_widgets.image.Image . width: Widget width in pixels. If not specified, the widget stretches to fill the parent widget. height: Widget height in pixels. If not specified, the widget stretches to fill the parent widget. content_gen: Function which generates a widget which is displayed as an overlay. This function should accept one or two keyword arguments:   event_gen (optional): Widget generator which yields events specified by the  drag_tag ,  down_tag , and  hover_tag arguments. The  event_gen argument is only used if any of those tags is not  None . For example usage, see the [image_events example](https: github.com/potocpav/python-concur/blob/master/examples/extra/image_events.py).   tf : Instance of  concur.extra_widgets.pan_zoom.TF . It can be used to transform between screen-space and image-space coordinates. The geometrical objects in  concur.draw take  tf as an optional argument. Widgets which don't accept the  tf argument, such as buttons, can be wrapped inside the  concur.widgets.transform widget. Any events fired by the widget generated by  content_gen are passed through unchanged. drag_tag: Mouse drag event tag. The event is  tag, (dx, dy) , where  dx, dy are the image-space coordinate differences from the last frame. down_tag: Mouse down event tag. The event is  tag, (x, y) , where  x, y is the image-space mouse position. The  down_tag fires once at the start of every mouse drag sequence. hover_tag: Mouse hover event tag. The event is  tag, (x, y) , where  x, y is the image-space mouse position. Returns: An image widget, which yields its state update events triggered by pan & zoom, and any events created inside the overlay specified by  content_gen .",
"func":1
},
{
"ref":"concur.extra_widgets.image.Image",
"url":5,
"doc":"Image state containing pan and zoom information, and texture data.  image  must be something convertible to  numpy.array : greyscale, RGB, or RGBA. Channel is in the last dimension."
},
{
"ref":"concur.extra_widgets.image.Image.change_image",
"url":5,
"doc":"Change the image for a different one.  image  must be None, or something convertible to  numpy.array in greyscale, RGB, or RGBA format. Channel is in the last dimension. If None, a black placeholder image is displayed.  change_image must be called at most once per each frame for one Image. For performance, it is beneficial to use NumPy textures:  with dimensions divisible by four,  with type  numpy.uint8 ,  with three or four channels (RGB, RGBA),  in C order. Otherwise, the array will be copied & converted.",
"func":1
},
{
"ref":"concur.extra_widgets.image.Image.reset_view",
"url":5,
"doc":"Reset view so that the whole image fits into the widget.",
"func":1
},
{
"ref":"concur.extra_widgets.pan_zoom",
"url":4,
"doc":"Zoomable, pannable widget with arbitrary content. This widget is rarely used directly by user code. Most of the time, it's more convenient to use higher-level widgets  concur.extra_widgets.image.image , or  concur.extra_widgets.frame.frame ."
},
{
"ref":"concur.extra_widgets.pan_zoom.pan_zoom",
"url":4,
"doc":"Create the Pan & Zoom widget, serving as a container for a thing given by  content_gen . This widget is mostly not used directly. Instead, a special-purpose wrapper can be used, such as  concur.extra_widgets.image.image , or  concur.extra_widgets.frame.frame . Args: name: widget name. Also serves as an event identifier state:  PanZoom object representing state. width: widget width in pixels. If  None , it fills the available space. height: widget height in pixels. If  None , it fills the available space. content_gen: Widget generator to display inside the pan-zoom widget. All events are passed through as a return tuple member. This is a function that returns a Concur widget, and takes two keyword arguments:   tf :  concur.extra_widgets.pan_zoom.TF object with transformation information   event_gen : This is an event generator which returns the drag, down, and hover events when they occur. It is up to the widget to do the necessary transformations using the  TF object, and optionally react to the events created by  event_gen . drag_tag: The event tag for LMB drag events. If  None , no drag events are fired. down_tag: The event tag for LMB down events. If  None , no down events are fired. Useful in combination with  drag_tag to indicate when the dragging started. hover_tag: The event tag for mouse hover when no mouse buttons are down. If  None , no hover events are fired. Events are fired only when the mouse is moving. Returns: To ease integration with other widgets, this widget returns events in a special format,  (name, state, event) .  state or  event may be  None in case  state didn't change, or there is no  event . If  drag_tag , or  down_tag arguments are used, these are fired in the  event member of the return tuple.",
"func":1
},
{
"ref":"concur.extra_widgets.pan_zoom.PanZoom",
"url":4,
"doc":"Pan & zoom state. Args: top_left: Coordinates of the top left corner of the displayed content area. bottom_right: Coordinates of the bottom right corner of the displayed content area. keep_aspect: Keep aspect ratio (x/y) equal to a given constant and zoom proportionally. If keep_aspect True, it is equivalent to keep_aspect 1. fix_axis: Do not zoom in a given axis ( 'x' ,  'y' , or  None ). margins: Margins (left, top, right, bottom) of the view area in pixels. If the view area should be inset by 5 px on each side, then use margins=[5,5,-5,-5]."
},
{
"ref":"concur.extra_widgets.pan_zoom.PanZoom.reset_view",
"url":4,
"doc":"Reset view to default values.",
"func":1
},
{
"ref":"concur.extra_widgets.pan_zoom.TF",
"url":4,
"doc":"Transformation object containing information necessary for converting between screen-space and image-space. Screen-space coordinates are in pixels with top-left window corner equal to (0, 0). Image space is arbitrary, given by the respective PanZoom widget state. Transformations are expressed as NumPy matrices in homogenous coordinates with two rows and three columns (shape:  (2, 3) ). For example, a point  [px, py] can be transformed to screen-space by left multiplication:   q = np.matmul(c2s, [px, py, 1])   Mostly, the necessary conversions are performed by overlay widgets in  concur.draw . It may be useful to transform stuff by hand in cases when default behavior is not sufficient, such as specifying the line width in image coordinates. The  hovered attribute is useful to highlight elements on mouse hover. Use  imgui.get_io().mouse_pos to get mouse position in screen-space and transform it using  TF.inv_transform into image coordinates. Attributes: c2s: Content-to-screen transformation matrix. s2c: Screen-to-content transformation matrix. view_s: Screen-space viewport coordinates as a list [left, top, right, bottom]. view_c: Image-space viewport coordinates as a list [left, top, right, bottom]."
},
{
"ref":"concur.extra_widgets.pan_zoom.TF.transform",
"url":4,
"doc":"Transform a given NumPy array of  n points of shape  (n, 2) from content-space to screen-space.",
"func":1
},
{
"ref":"concur.extra_widgets.pan_zoom.TF.inv_transform",
"url":4,
"doc":"Transform a given NumPy array of  n points of shape  (n, 2) from screen-space to content-space.",
"func":1
},
{
"ref":"concur.integrations",
"url":6,
"doc":"Integration with the host system: windowing, user input, etc. Even using PyImGui's integration code, quite a bit of boilerplate is needed just to create a window, or to display an image. This module provides functions that simplify getting stuff rendered to just a couple of lines of code."
},
{
"ref":"concur.integrations.opengl",
"url":7,
"doc":"Raw OpenGL functions, mostly for creating and deleting textures."
},
{
"ref":"concur.integrations.opengl.texture",
"url":7,
"doc":"Create a new OpenGL texture and return its texture ID.",
"func":1
},
{
"ref":"concur.integrations.opengl.rm_textures",
"url":7,
"doc":"Delete a list of OpenGL textures.",
"func":1
},
{
"ref":"concur.integrations.opengl.rm_texture",
"url":7,
"doc":"Delete a single OpenGL texture.",
"func":1
},
{
"ref":"concur.integrations.opengl.replace_texture",
"url":7,
"doc":"Convenience function: delete the texture  prev_tex_id , if not  None , and create a new one, returning its texture ID.",
"func":1
},
{
"ref":"concur.integrations.quick",
"url":8,
"doc":"Simple plotting functions designed to monitor a process without slowing it down too much (experimental). This is not a simple task, as threading in Python is slow, and multiprocessing is fiddly I am not happy with these interfaces yet, and they may change or be removed in the future."
},
{
"ref":"concur.integrations.quick.thread",
"url":8,
"doc":"",
"func":1
},
{
"ref":"concur.integrations.quick.quick_plot_w",
"url":8,
"doc":"",
"func":1
},
{
"ref":"concur.integrations.quick.quick_plot",
"url":8,
"doc":"",
"func":1
},
{
"ref":"concur.integrations.quick.quick_window_w",
"url":8,
"doc":"",
"func":1
},
{
"ref":"concur.integrations.quick.quick_window",
"url":8,
"doc":"",
"func":1
},
{
"ref":"concur.integrations.quick.quick_image_w",
"url":8,
"doc":"",
"func":1
},
{
"ref":"concur.integrations.quick.quick_image",
"url":8,
"doc":"",
"func":1
},
{
"ref":"concur.integrations.puppet",
"url":9,
"doc":"Automation back-end with screen capture and programmatical user input. Normally, this is used with functions in  concur.testing ."
},
{
"ref":"concur.integrations.puppet.PuppetRenderer",
"url":9,
"doc":"Renderer for automated testing. User inputs are set programmatically, rather than interactively."
},
{
"ref":"concur.integrations.puppet.PuppetRenderer.process_inputs",
"url":9,
"doc":"Process the virtual user inputs. Called by  main at the beginning of each frame.",
"func":1
},
{
"ref":"concur.integrations.puppet.PuppetRenderer.click",
"url":9,
"doc":"Simulate a mouse button click.  0  left button  1  right button  2  middle button",
"func":1
},
{
"ref":"concur.integrations.puppet.PuppetRenderer.set_mouse_pos",
"url":9,
"doc":"Set the mouse cursor position to a specified value.",
"func":1
},
{
"ref":"concur.integrations.puppet.PuppetRenderer.scroll_up",
"url":9,
"doc":"Scroll the mouse wheel up one click.",
"func":1
},
{
"ref":"concur.integrations.puppet.PuppetRenderer.scroll_dn",
"url":9,
"doc":"Scroll the mouse wheel down one click.",
"func":1
},
{
"ref":"concur.integrations.puppet.PuppetRenderer.mouse_dn",
"url":9,
"doc":"Push a specified mouse button.",
"func":1
},
{
"ref":"concur.integrations.puppet.PuppetRenderer.mouse_up",
"url":9,
"doc":"Release a specified mouse button.",
"func":1
},
{
"ref":"concur.integrations.puppet.PuppetRenderer.key_dn",
"url":9,
"doc":"",
"func":1
},
{
"ref":"concur.integrations.puppet.PuppetRenderer.key_up",
"url":9,
"doc":"",
"func":1
},
{
"ref":"concur.integrations.puppet.PuppetRenderer.write_char",
"url":9,
"doc":"Write a character with a given char code.",
"func":1
},
{
"ref":"concur.integrations.puppet.main",
"url":9,
"doc":"Create a GLFW window, spin up the main loop, and display a given widget inside. The resulting window is not hooked up to the user input. Instead, input is handled by a PuppetRenderer instance.  widget_gen takes as an argument a  PuppetRenderer instance, and returns a widget.  fps optionally limits FPS (if None, FPS is unlimited)",
"func":1
},
{
"ref":"concur.integrations.glfw",
"url":10,
"doc":"Main integration back-end."
},
{
"ref":"concur.integrations.glfw.PatchedGlfwRenderer",
"url":10,
"doc":"Custom variant of Glfwrenderer in PyImGui: https: github.com/swistakm/pyimgui/blob/master/imgui/integrations/glfw.py This works around the issue that GLFW uses EN_US keyboard to specify the key codes in  keyboard_callback . This meant that keyboard shortcuts were broken on non-querty keyboard layouts. See https: github.com/ocornut/imgui/issues/2959 for details.  Temporary try except fix until we find a better solution, if we don't apply this,  the app will crash if certain special keys are pressed."
},
{
"ref":"concur.integrations.glfw.PatchedGlfwRenderer.keyboard_callback",
"url":10,
"doc":"",
"func":1
},
{
"ref":"concur.integrations.glfw.main",
"url":10,
"doc":"Create a GLFW window, spin up the main loop, and display a given widget inside. To create a maximized window, pass width and height larger than the screen. Args: widget: The widget to display inside the window. When the widget returns, the application exits. name: Window name, displayed in the title bar and other OS outputs. width: Desired window width. height: Desired window height. fps: Maximum number of frames per second save_screencast: Capture and save the UI into a specified video file (experimental). Main window shouldn't be resized while the application is running when using this option. screencast_fps: Save the screencast video with a given FPS. menu_bar: Reserve space for  concur.widgets.main_menu_bar at the top of the window. maximized: Create a maximized window.",
"func":1
},
{
"ref":"concur.testing",
"url":11,
"doc":"Routines for automated testing. The current automation/testing setup is work-in-progress, and the interface may change radically in future versions. There are some usability issues that I am not entirely happy with. See the [tests directory](https: github.com/potocpav/python-concur/tree/master/tests) for usage examples."
},
{
"ref":"concur.testing.test_widget",
"url":11,
"doc":"Function decorator for testing functions. Dead simple usage example, which just displays a button for a moment is:   @c.testing.test_widget def test_example(tester): yield from c.orr([c.button(\"Test Button\"), tester.pause()]) if __name__  '__main__': test_example()   This can be invoked either directly ( python test_example.py ), or using PyTest ( pytest -k test_example ). To slow the test down, set the environmental variable  SLOW_TEST=1 :   SLOW_TEST=1 python test_example.py  or SLOW_TEST=1 pytest -k test_example   The decorated testing function takes a single argument  tester , which contains a  Testing class instance. This class provides convenient functions for user input automation, wrapping the raw user interaction primitives from  concur.integrations.puppet.PuppetRenderer .",
"func":1
},
{
"ref":"concur.testing.benchmark_widget",
"url":11,
"doc":"Benchmark a widget (experimental). See tests/test_draw.py for example usage.",
"func":1
},
{
"ref":"concur.testing.Testing",
"url":11,
"doc":"Must be used in conjunction with the  concur.integrations.puppet backend. To setup all the plumbing effortlessly, use the  test_widget decorator. All the methods in this class are widgets, and they can be composed as usual using  concur.core.orr ,  yield from , and friends."
},
{
"ref":"concur.testing.Testing.click",
"url":11,
"doc":"Click a given mouse button.",
"func":1
},
{
"ref":"concur.testing.Testing.click_next",
"url":11,
"doc":"Click the next widget.",
"func":1
},
{
"ref":"concur.testing.Testing.mark",
"url":11,
"doc":"Display a widget, but mark it with a name so it can be interacted with at a later point using methods such as  click_marked .",
"func":1
},
{
"ref":"concur.testing.Testing.click_marked",
"url":11,
"doc":"Click the given  marked widget. Optionally, specify the click offset  x, y coords.",
"func":1
},
{
"ref":"concur.testing.Testing.move_cursor",
"url":11,
"doc":"Move cursor to a given position.",
"func":1
},
{
"ref":"concur.testing.Testing.scroll_up",
"url":11,
"doc":"Scroll up.",
"func":1
},
{
"ref":"concur.testing.Testing.scroll_dn",
"url":11,
"doc":"Scroll down.",
"func":1
},
{
"ref":"concur.testing.Testing.mouse_up",
"url":11,
"doc":"Release the given mouse button.",
"func":1
},
{
"ref":"concur.testing.Testing.mouse_dn",
"url":11,
"doc":"Push the given mouse button.",
"func":1
},
{
"ref":"concur.testing.Testing.write_char",
"url":11,
"doc":"Write a given character.",
"func":1
},
{
"ref":"concur.testing.Testing.pause",
"url":11,
"doc":"Pause for a specified number of frames. If  nframes <= 0, the pause length depends on the environment variable  TEST_SLOW .",
"func":1
},
{
"ref":"concur.colors",
"url":12,
"doc":"Color dictionary. [XKCD colors](https: xkcd.com/color/rgb/) are used."
},
{
"ref":"concur.colors.color_to_rgba",
"url":12,
"doc":"",
"func":1
},
{
"ref":"concur.colors.color_to_rgba_tuple",
"url":12,
"doc":"",
"func":1
},
{
"ref":"concur.core",
"url":13,
"doc":"Core functionality, widget creation, manipulation, and composition. All of the functions in this module are re-exported in the root module for convenience."
},
{
"ref":"concur.core.orr",
"url":13,
"doc":"Chain elements in space, returning the first event fired. This is the principal way to compose widgets in Concur. Windows, for example, typically contain multiple widgets composed into one by  orr :   c.window(\"Buttons\", c.orr([ c.button(\"Button 1\"), c.button(\"Button 2\"), ]   Widgets are laid out vertically. For horizontal layout, use  concur.widgets.orr_same_line .",
"func":1
},
{
"ref":"concur.core.multi_orr",
"url":13,
"doc":"Chain elements in space, returning all the events fired as a list. This is an alternative to  concur.core.orr which doesn't throw away events, but is somewhat less convenient to compose. Care must be taken not to update the same state variable twice as a reaction to two different concurrent events. The first update may get overwritten. Mostly, the transition from  orr to  multi_orr is trivial. Replace this:   key, value = c.orr([ .])  update if key   :  . elif key   :  .   with this:   events = c.multi_orr([ .]) for key, value in events:  update if key   :  . elif key   :  .  ",
"func":1
},
{
"ref":"concur.core.forever",
"url":13,
"doc":"Repeat a widget forever. Function generating the widget must be passed as the first argument; remaining arguments are passed to said function. This can be used to easily suppress any widget events, like this:   c.forever(c.button, \"Not Clickable\")  ",
"func":1
},
{
"ref":"concur.core.lift",
"url":13,
"doc":"Lift a function into a never-ending widget. Useful for wrapping ImGui calls and passive widgets. For example, to create a text widget:   c.lift(imgui.text, \"some text\")  ",
"func":1
},
{
"ref":"concur.core.interactive_elem",
"url":13,
"doc":"Function useful for wrapping a wide range of ImGui widgets. Elements which take  name as the first argument and return a pair  (changed, value) can be wrapped using this function. It is used to wrap many imgui widgets in  concur.widgets .",
"func":1
},
{
"ref":"concur.core.nothing",
"url":13,
"doc":"Widget that does nothing forever.",
"func":1
},
{
"ref":"concur.core.event",
"url":13,
"doc":"Widget that immediately returns  ev .",
"func":1
},
{
"ref":"concur.core.optional",
"url":13,
"doc":"Optionally display a widget.",
"func":1
},
{
"ref":"concur.core.tag",
"url":13,
"doc":"Transform any returned value  v of  elem into a tuple  tag_name, v .",
"func":1
},
{
"ref":"concur.core.tag_value",
"url":13,
"doc":"Transform any returned value  (t, v) of  elem into a tuple  t, (tag_name, v) . Useful for identifying elements in lists and tables.",
"func":1
},
{
"ref":"concur.core.map",
"url":13,
"doc":"Transform any returned value  v of  elem into  f(v) .",
"func":1
},
{
"ref":"concur.core.replace",
"url":13,
"doc":"Replace the event returned by  elem with  event .",
"func":1
},
{
"ref":"concur.core.replace_tag",
"url":13,
"doc":"Replace the first element of any returned pair with  tag .",
"func":1
},
{
"ref":"concur.core.replace_value",
"url":13,
"doc":"Replace the second element of any returned pair with  value .",
"func":1
},
{
"ref":"concur.core.stateful",
"url":13,
"doc":"Thread state from the widget into itself, creating a stateful never-ending widget. Explicit state threading is mostly better than using this function, due to the added flexibility and due to the fact than excessive use of higher-order functions is not very Pythonic.",
"func":1
},
{
"ref":"concur.core.Block",
"url":13,
"doc":"Create a widget that returns on [Future](https: docs.python.org/3.9/library/asyncio-future.html asyncio.Future) result. This is useful for easily doing async computations. For an usage example, see the [timers example](https: github.com/potocpav/python-concur/blob/master/examples/timers.py). This widget is constructed manually using a class, because the future must be canceled in the destructor. Destructor isn't available in generator functions."
},
{
"ref":"concur.core.listen",
"url":13,
"doc":"Listen for messages in a given queue.",
"func":1
},
{
"ref":"concur.draw",
"url":14,
"doc":"Passive geometric shape widgets to be drawn as  concur.extra_widgets.image.image or  concur.extra_widgets.frame.frame overlay, or on their own. All these widgets have the following in common:  They are passive, so they don't need names. For active overlay, several mechanisms can be used, listed below.  They don't do automatic layout. Instead the exact position is specified by hand.  Color can be specified in several ways:  RGBA tuple with values between 0 and 1. For example,  (0.5, 0.5, 1, 1) is light blue.  RGB tuple with values between 0 and 1. The result is opaque.  String specifying a color from the [xkcd color set](https: xkcd.com/color/rgb/), for example,  'red' .   (str, float) pair, where the first element specifies color, and the second element specifies alpha.  A single  int , specifying ABGR color. For example,  0xffaa0000 is dark blue.   tf is the  concur.extra_widgets.pan_zoom.TF object specifying transformations from screen-space to image-space and back. If no transformation is supplied, the element is drawn in screen space units. Theses widgets are not re-exported in the root module, and are normally used as  c.draw.line( .) , etc. They can be composed normally using the  concur.core.orr function.  Creating Interactive Overlays There are several ways of creating overlays which react to user input.   Using interactive widgets as overlay . Widgets, such as buttons, can be displayed as overlay at a specified position using the  concur.widgets.transform function. This can be used also for dragging stuff by wrapping the widget in a  concur.extra_widgets.draggable.draggable . To create rectangular clickable areas, the  concur.widgets.invisible_button widget can be used. See the [image example](https: github.com/potocpav/python-concur/blob/master/examples/image.py) for a basic usage example.   Using the events managed by  concur.extra_widgets.image.image and  concur.extra_widgets.frame.frame . The  drag_tag ,  down_tag , and  hover_tag arguments can be used to implement complex interactions, such as control point editing. See the [image_events](https: github.com/potocpav/python-concur/blob/master/examples/extra/image_events.py) example for a basic usage example. This option will give you click/hover positions and drag deltas, but it is up to you to implement any logic on top of that, such as highlighting the hovered line, etc.   Using the  concur.widgets.mouse_click widget . This widget just returns mouse position for any click not inside any widget. This is the simplest option, but it is probably better to use the other options. See the [annotation tool](https: github.com/potocpav/annotation-tool/blob/master/annotator.py) example for an usage example."
},
{
"ref":"concur.draw.line",
"url":14,
"doc":"Line connecting two points.",
"func":1
},
{
"ref":"concur.draw.rect",
"url":14,
"doc":"Straight non-filled rectangle specified by its two corners.",
"func":1
},
{
"ref":"concur.draw.rects",
"url":14,
"doc":"Multiple straight non-filled rectangles specified by their two corners.  rects is a NumPy array of shape  (n, 4) , where  n is the number of rectangles.",
"func":1
},
{
"ref":"concur.draw.rect_filled",
"url":14,
"doc":"Straight non-filled rectangle specified by its two corners.",
"func":1
},
{
"ref":"concur.draw.circle",
"url":14,
"doc":"Circle specified by its center and radius.",
"func":1
},
{
"ref":"concur.draw.polyline",
"url":14,
"doc":"Polygonal line or a closed polygon.  points is a list of (x, y) tuples, or a NumPy array of equivalent shape.",
"func":1
},
{
"ref":"concur.draw.polygon",
"url":14,
"doc":"Filled polygon. Points must form a convex area.  points is a list of (x, y) tuples, or a NumPy array of equivalent shape.",
"func":1
},
{
"ref":"concur.draw.polylines",
"url":14,
"doc":"Multiple polygonal lines with the same length and parameters. Calling this function is more efficient than calling  polyline multiple times, because all the data is given to the C back-end in one Python call, and because transformation is vectorized.  points is a NumPy array with shape  (n, m, 2) , where  n is the number of polylines, and  m is the number of points in each polyline.",
"func":1
},
{
"ref":"concur.draw.polygons",
"url":14,
"doc":"Multiple filled polygons with the same length and color. Calling this function is more efficient than calling  polygon multiple times, because all the data is given to the C back-end in one Python call, and because transformation is vectorized.  points is a NumPy array with shape  (n, m, 2) , where  n is the number of polygons, and  m is the number of points in each polyline.",
"func":1
},
{
"ref":"concur.draw.text",
"url":14,
"doc":"Text, using the default font and font size. This is a raw drawing function. Use  concur.widgets.text instead if you want a text widget.",
"func":1
},
{
"ref":"concur.draw.image",
"url":14,
"doc":"Draw an image with the given origin (x, y), width and height. This is a raw drawing function. Use  concur.extra_widgets.image.image instead if you want an image widget. Note that OpenGL textures may be rendered incorrectly if width or height isn't divisible by 4.",
"func":1
},
{
"ref":"concur.draw.ellipse",
"url":14,
"doc":"Ellipse defined by a mean, covariance matrix, and SD.",
"func":1
},
{
"ref":"concur.draw.ellipses",
"url":14,
"doc":"Multiple ellipses defined by a means, covariance matrices, and SD. The call is very similar to  ellipse , but  mean and  cov are vectorized: there is one more dimension (zeroth) for both. For  n ellipses, the shape of  mean is  (n, 2) , and the shape of  cov is  (n, 2, 2) .",
"func":1
},
{
"ref":"concur.draw.scatter",
"url":14,
"doc":"Draw a scatter plot with given marker settings. If multiple settings are desired (such as two distinct point colors), call this function more than once with different parameters. Some markers are more performant than others, depending on the amount of generated geometry. Args: pts: NumPy array with shape  (n, 2) , where  n is the point count. color: Color to draw the markers. marker: Marker type. See the table below. marker_size: Size of the markers in pixels. thickness: Line width for non-filled markers    marker | description    |  -  \".\" | filled square  \"x\" | cross  \"+\" | plus sign  \"o\" | non-filled circle  \"s\" | non-filled square  \"|\" | vertical line  \"-\" | horizontal line",
"func":1
},
{
"ref":"concur.widgets",
"url":15,
"doc":"A collection of widgets based off of ImGui. By convention, most widgets take a string identifier as the first parameter, and return the  (identifier, value) pair. This is done for convenience, as Python syntax for mapping values is a bit busy. If you want to return a different identifier to what is displayed on screen, use the  tag keyword argument which is available for all widgets where it makes sense. Most widgets are just thin wrappers over [widgets in PyImGui](https: pyimgui.readthedocs.io/en/latest/reference/imgui.core.html). If any widget from ImGui is not listed here, it is mostly trivial to add it. New widgets can be created by writing generators by hand, or by using helper functions  concur.core.interactive_elem or  concur.core.lift . Some widgets ( transform ,  key_press , etc.) don't do any drawing and serve purely for control flow, or user interaction. All of the functions in this module are re-exported in the root module for convenience."
},
{
"ref":"concur.widgets.orr_same_line",
"url":15,
"doc":"Use instead of  concur.core.orr to layout child widgets horizontally instead of vertically.",
"func":1
},
{
"ref":"concur.widgets.window",
"url":15,
"doc":"Create a window with a given  widget inside. Contents are drawn only if the window is opened.   Window title must be unique. Contents of windows with an identical title will appear inside a single window.   Windows must not be nested. Nested windows may lead to visibility feedback loops, which manifests as flicker on some docking operations.",
"func":1
},
{
"ref":"concur.widgets.child",
"url":15,
"doc":"Create a sized box with a  widget inside. If the contents overflow, scrollbars will be created by default. Sizing of the child widget allows for three modes, depending on the sign of parameters  width and  height :   0 - use the remaining window size  \\>0 - fixed size in pixels  <0 - use remaining window size minus abs(size) in pixels Args: name: Child name. This has no effect, and will be removed in the future. widget: Widget to display inside the box. width: Box width. height: Box height. border: Toggle border visibility. flags: Advanced customization flags. See the [list of available flags](https: pyimgui.readthedocs.io/en/latest/guide/window-flags.html window-flag-options).",
"func":1
},
{
"ref":"concur.widgets.collapsing_header",
"url":15,
"doc":"Display a collapsible section header. It can be open or closed by default (parameter  open ).",
"func":1
},
{
"ref":"concur.widgets.tree_node",
"url":15,
"doc":"Display a collapsible tree node. It can be open or closed by default (parameter  open ). Tree node content has left offset, unlike  collapsing_header .",
"func":1
},
{
"ref":"concur.widgets.button",
"url":15,
"doc":"Button. Returns  (label, None) on click, or  (tag, None) if tag is specified.",
"func":1
},
{
"ref":"concur.widgets.image_button",
"url":15,
"doc":"Image button. Returns  (name, None) on click. Args: texture_id: OpenGL texture ID size: image display size two-tuple uv0: UV coordinates for 1st corner (lower-left for OpenGL) uv1: UV coordinates for 2nd corner (upper-right for OpenGL) tint_color: Image tint color border_color: Image border color frame_padding: Frame padding (0: no padding, <0 default padding)",
"func":1
},
{
"ref":"concur.widgets.invisible_button",
"url":15,
"doc":"Invisible button with a given width and height. Can be interacted with as a normal button, including clicking and dragging. Returns  (label, None) on click, or  (tag, None) if tag is specified.",
"func":1
},
{
"ref":"concur.widgets.color_button",
"url":15,
"doc":"Colored button. Color can be specified in multiple ways listed in [concur.draw]. Returns  (label, None) on click, or  (tag, None) if tag is specified.",
"func":1
},
{
"ref":"concur.widgets.radio_button",
"url":15,
"doc":"Radio button. Returns  (label, None) on click, or  (tag, None) if tag is specified.",
"func":1
},
{
"ref":"concur.widgets.dummy",
"url":15,
"doc":"Add a dummy element of a given  width and  height . Useful for custom-sized vertical and horizontal spacings.",
"func":1
},
{
"ref":"concur.widgets.input_text",
"url":15,
"doc":"Text input. Flags are [defined by PyImGui](https: pyimgui.readthedocs.io/en/latest/guide/inputtext-flags.html inputtext-flag-options).  buffer_length doesn't affect widget size on screen, it limits the maximum character count only.",
"func":1
},
{
"ref":"concur.widgets.input_text_multiline",
"url":15,
"doc":"Multiline text input. Flags are [defined by PyImGui](https: pyimgui.readthedocs.io/en/latest/guide/inputtext-flags.html inputtext-flag-options).",
"func":1
},
{
"ref":"concur.widgets.key_press",
"url":15,
"doc":"Invisible widget that waits for a given key to be pressed. No widget must be active at the time to prevent triggering hotkeys by editing text fields. Key codes are specified by glfw, e.g.  glfw.KEY_A , or  glfw.KEY_SPACE . Upper-case ASCII codes also work, such as ord('A').",
"func":1
},
{
"ref":"concur.widgets.mouse_click",
"url":15,
"doc":"Invisible widget that waits for a given mouse button to be clicked (default: LMB). This function is triggered only when no widgets are interacted with using mouse. Event is returned in the format  (name, (x, y  , where  (x, y) are the coordinates of the clicked position.",
"func":1
},
{
"ref":"concur.widgets.text_tooltip",
"url":15,
"doc":"Display a text tooltip on hover",
"func":1
},
{
"ref":"concur.widgets.tooltip",
"url":15,
"doc":"Display a widget tooltip on hover. May contain arbitrary elements, such as images.",
"func":1
},
{
"ref":"concur.widgets.main_menu_bar",
"url":15,
"doc":"Create a main menu bar. This requires setting  menu_bar=True in the  concur.integrations.glfw.main method. Otherwise, space wouldn't be reserved for the menu bar, and it would lay on top of window contents. Main menu bar must be created outside any windows. See [examples/extra/menu_bar.py](https: github.com/potocpav/python-concur/tree/master/examples/extra/menu_bar.py) for an usage example.",
"func":1
},
{
"ref":"concur.widgets.menu",
"url":15,
"doc":"Create an expandable menu in the  main_menu_bar . Widgets commonly used in menus are  menu_item , and  separator .",
"func":1
},
{
"ref":"concur.widgets.menu_item",
"url":15,
"doc":"Create a menu item. Menu items should be nested inside  menu . Item shortcuts are displayed for convenience, but are not processed in any way. They are easily handled by  key_press outside the menu code If  key_press was inside the menu, it would not be active when the menu is not expanded. Items may have a check-box ( selected ), and may or may not be  enabled .",
"func":1
},
{
"ref":"concur.widgets.separator",
"url":15,
"doc":"Horizontal separator.",
"func":1
},
{
"ref":"concur.widgets.spacing",
"url":15,
"doc":"Extra vertical space.",
"func":1
},
{
"ref":"concur.widgets.font",
"url":15,
"doc":"Render  widget with a given font. The easiest way to create  font_ is probably to call this before the call to  concur.integrations.glfw.main :   imgui.create_context() font = imgui.get_io().fonts.add_font_from_file_ttf(\"font_file.ttf\", 16)   See the [font guide in PyImGui](https: pyimgui.readthedocs.io/en/latest/guide/using-fonts.html) for more details.",
"func":1
},
{
"ref":"concur.widgets.text",
"url":15,
"doc":"Passive text display widget.",
"func":1
},
{
"ref":"concur.widgets.text_wrapped",
"url":15,
"doc":"Word wrapping text display widget. Recommended for long chunks of text.",
"func":1
},
{
"ref":"concur.widgets.text_colored",
"url":15,
"doc":"Passive colored text display widget.",
"func":1
},
{
"ref":"concur.widgets.selectable",
"url":15,
"doc":"Selectable line. This widget marks the whole line as selectable. To add widgets to  selectable , simply append them using  orr_same_line :   c.orr_same_line([ c.selectable(\"Selectable\", False), c.text(\"Extra text\"), ])  ",
"func":1
},
{
"ref":"concur.widgets.checkbox",
"url":15,
"doc":"Two-state checkbox.",
"func":1
},
{
"ref":"concur.widgets.drag_float",
"url":15,
"doc":"Float selection widget without a slider.",
"func":1
},
{
"ref":"concur.widgets.drag_float2",
"url":15,
"doc":"Float selection widget without a slider for selecting two  values .",
"func":1
},
{
"ref":"concur.widgets.drag_float3",
"url":15,
"doc":"Float selection widget without a slider for selecting three  values .",
"func":1
},
{
"ref":"concur.widgets.drag_float4",
"url":15,
"doc":"Float selection widget without a slider for selecting four  values .",
"func":1
},
{
"ref":"concur.widgets.drag_int",
"url":15,
"doc":"Integer selection widget without a slider.",
"func":1
},
{
"ref":"concur.widgets.drag_int2",
"url":15,
"doc":"Integer selection widget without a slider for selecting two  values .",
"func":1
},
{
"ref":"concur.widgets.drag_int3",
"url":15,
"doc":"Integer selection widget without a slider for selecting three  values .",
"func":1
},
{
"ref":"concur.widgets.drag_int4",
"url":15,
"doc":"Integer selection widget without a slider for selecting four  values .",
"func":1
},
{
"ref":"concur.widgets.input_float",
"url":15,
"doc":"Float input widget.",
"func":1
},
{
"ref":"concur.widgets.slider_int",
"url":15,
"doc":"Int selection slider.",
"func":1
},
{
"ref":"concur.widgets.slider_float",
"url":15,
"doc":"Float selection slider.",
"func":1
},
{
"ref":"concur.widgets.test_window",
"url":15,
"doc":"ImGui test window with a multitude of widgets.",
"func":1
},
{
"ref":"concur.widgets.drag_drop_source",
"url":15,
"doc":"Drag-and-Drop Source Widget. This widget is used in conjunction with  concur.widgets.drag_drop_target . See the [https: github.com/potocpav/python-concur/blob/master/examples/extra/drag_and_drop.py](examples/extra/drag_and_drop.py) for an example. Args: tag: Drag-and-Drop event tag. Must match the tag in  drag_drop_target . payload: Pickle-able value which is to be returned in the drag-and-drop event. widget: Widget which can be dragged. dragged_widget: Widget inside the tooltip which is displayed while dragging. Defaults to a  widget copy. flags: Flags to modify dragging behavior. See [the pyimgui docs](https: pyimgui.readthedocs.io/en/latest/reference/imgui.html?highlight=WINDOW_MENU_BAR imgui.DRAG_DROP_SOURCE_NO_PREVIEW_TOOLTIP) for the flag list.",
"func":1
},
{
"ref":"concur.widgets.drag_drop_target",
"url":15,
"doc":"Drag-and-Drop Target Widget. This widget is used in conjunction with  concur.widgets.drag_drop_source . On widget drop, an event is generated which contains the payload from source, and the value from targed, and is shaped like this:  (tag, (source_payload, value  . Args: tag: Drag-and-Drop event tag. Must match the tag in  drag_drop_source . value: Value added to the event. widget: Widget which accepts the drag-and-drop event.",
"func":1
},
{
"ref":"concur.widgets.columns",
"url":15,
"doc":"Table, using the imgui columns API. Args: elems (List[List[Widget ): 2D array of widgets. A list containing another list for each row. len() of the first row defines the amount of columns, that will be rendered. > Do note, that despite the first row defines the amount of rendered columns, all rows still must have the the same len(). < identifier (str): Name of the widget. vert_borders (bool): Toggle vertical borders on/off. hor_borders (bool): Toggle horizontal borders on/off. widths (List[Union[int,float ): is an optional vector of column widths in pixels. May contain None values. Returns:  concur.core.orr wrapping the column widget including all its rows.",
"func":1
},
{
"ref":"concur.widgets.transform",
"url":15,
"doc":"Use  concur.extra_widgets.pan_zoom.TF and a specified position  x, y to transform a widget. Only widget position will be affected (not scaling), and it will be positioned so that its upper left corner is at  [x, y] .",
"func":1
}
]